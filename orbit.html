<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Earth‚ÄìMoon System Visualization</title>
  <style>
    :root {
      /* Color definitions */
      --color-black: #000;
      --color-white: #fff;
      --color-primary: rgba(255,255,255,.12);
      --color-primary-hover: rgba(255,255,255,.25);
      --color-border: rgba(255,255,255,.35);
      --color-border-light: rgba(255,255,255,.25);
      --color-background: rgba(0,0,0,.35);
      --color-orbit: #4488ff;
      /* Opacity definitions */
      --opacity-disabled: 0.35;
      --opacity-enabled: 1;
    }
    body {
      margin: 0;
      overflow: hidden;
      background: var(--color-black);
    }
    #hud {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      color: var(--color-white);
      font: 14px/1.2 system-ui, sans-serif;
      pointer-events: none; /* let clicks pass through by default */
    }
    .hud__row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 12px;
      margin: 0 auto 4px auto;
      width: 96%;
      max-width: 900px;
      background: var(--color-background);
      backdrop-filter: blur(8px);
      border: 1px solid var(--color-border-light);
      border-radius: 8px;
      pointer-events: auto;
    }
    .hud__group { display: flex; align-items: center; gap: 8px; }
    input, button {
      font: inherit; color: inherit; background: var(--color-primary);
      border: 1px solid var(--color-border);
      border-radius: 4px; padding: 4px 6px;
    }
    button { cursor: pointer; min-width: 32px; }
    button:hover { background: var(--color-primary-hover); }
    input[type=range] { width: 90px; accent-color: var(--color-primary); background: var(--color-primary); }
    #speedOut { width: 58px; text-align: right; }
    /* camera row */
    .hud__cam { justify-content: flex-start; gap: 6px; }
    .camBtn { width: 32px; opacity: var(--opacity-disabled); }
    .camBtn.saved { opacity: var(--opacity-enabled); }
    #camStore { margin-left: auto; margin-right: 6px; }
    #camClose { background: none; border: none; opacity: .7; }
    /* lock indicator */
    #linkIndicator {
      display: none;
      font-size: 16px;
      padding: 4px 6px;
      background: transparent;
      border: none;
    }
    #linkIndicator.active {
      display: block;
    }
  </style>
</head>
<body>
<div id="hud">
  <div class="hud__row hud__main">
    <!-- LEFT -->
    <div class="hud__group">
      <label title="Date / Time (UTC+2)">
        <input id="simDate" type="date">
        <input id="simTime" type="time" step="60">
      </label>
      <span id="simElapsed">+0.0 d</span>
    </div>

    <!-- CENTRE -->
    <div class="hud__group">
      <button id="btnReverse" aria-label="Reverse time">‚ñª</button>
      <button id="btnPlay"   aria-label="Play/Pause">‚è∏</button>
      <button id="btnReset"  aria-label="Reset">‚ü≤</button>
    </div>

    <!-- RIGHT -->
    <div class="hud__group">
      <input id="speedSlider" type="range" min="0" max="50" step="0.5" value="1">
      <output id="speedOut" for="speedSlider">1 √ó</output>
    </div>
  </div>

  <!-- Second row: camera snapshots -->
  <div class="hud__row hud__cam" id="camRow" hidden>
    <button class="camBtn" data-slot="1">1</button>
    <button class="camBtn" data-slot="2">2</button>
    <button class="camBtn" data-slot="3">3</button>
    <div id="linkIndicator" title="Camera linked">üîí</div>
  </div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "orbitControls": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js"
  }
}
</script>

<script type="module">

/*
  TODO:
    - highlight orbital nodes, perigee, apogee
    - Add stars background
*/

import * as THREE from 'three';
import { OrbitControls } from 'orbitControls';

// ============================================================================
// CONSTANTS AND HELPER FUNCTIONS
// ============================================================================

const EARTH_TEXTURE_URL = 'textures/earth_atmos_2048.jpg';
const MOON_TEXTURE_URL = 'textures/moon_1024.jpg';
const SKY_TEXTURE_URL = [  // In celestial coordinates from https://svs.gsfc.nasa.gov/4851
    'textures/sky_px.png', // Right
    'textures/sky_nx.png', // Left
    'textures/sky_py.png', // Top
    'textures/sky_ny.png', // Bottom
    'textures/sky_pz.png', // Front
    'textures/sky_nz.png'  // Back
];

// Scale conversion constants
const KM_PER_UNIT = 1200; // Earth radius is ~5.3 units in this scale
const toUnits = km => km / KM_PER_UNIT;
const toRadians = degrees => degrees * Math.PI / 180;

// Physical properties (in kilometers, converted to scene units)
const EARTH_RADIUS_KM = 6371 * 4; // Scaled up for visibility
const MOON_RADIUS_KM = 1737 * 4;
const MOON_DISTANCE_KM = 384400;
const EARTH_AXIAL_TILT = 23.44; // degrees
const MOON_AXIAL_TILT = 6.68; // degrees

// Time constants for simulation
const SIMULATION_MINUTE = 1;  // 1 minute of real time represents 1 hour in simulation
const SIMULATION_HOUR = 60 * SIMULATION_MINUTE;
const SIMULATION_DAY = 24 * SIMULATION_HOUR;
const SIMULATION_YEAR = 365.25 * SIMULATION_DAY;
const MOON_ORBITAL_PERIOD = 27.55455 * SIMULATION_DAY; // anomalistic period
const EARTH_ROTATION_PERIOD = 23.93447 * SIMULATION_HOUR; // sidereal day
const EARTH_PRECESSION_PERIOD = 25772 * SIMULATION_YEAR; // Period in hours
const SUN_ORBITAL_PERIOD = 365.25 * SIMULATION_DAY; // sidereal year
const MOON_NODE_PRECESSION_PERIOD = 18.613 * SIMULATION_YEAR; // Cassini-state orientation

// Helpers to calculate date differences
function daysSinceSolstice(targetDate) {
  const year = targetDate.getFullYear();
  // The Summer Solstice in 2025 occurs on June 21 at 03:42 UTC.
  // We use this precise time as our "zero angle" reference point.
  const solstice = new Date(Date.UTC(year, 5, 21, 3, 42, 0));
  return (targetDate - solstice) / (1000 * 60 * 60 * 24); // Convert milliseconds to days
}

// Our reference date is September 10, 2025
const REFERENCE_DATE = new Date('2025-09-10T00:00:00Z');
const DAYS_SINCE_SOLSTICE = daysSinceSolstice(REFERENCE_DATE);

/*
    Init all orbital parameters out of JPL Horizons data for September 10, 2025
    https://ssd.jpl.nasa.gov/horizons/app.html

    Reference frame : Ecliptic of J2000.0

    Origin: The center of the Earth

    Fundamental Plane: The Earth's mean orbital plane (the ecliptic) as it was at the J2000.0 epoch.

    Z-axis: A line perpendicular to this ecliptic plane, pointing north.

    X-axis: This primary direction points towards the vernal equinox, the point where the Sun crosses
            the celestial equator from south to north‚Äîas it was at the J2000.0 epoch.

    Y-axis: 90¬∞ ahead of the X-axis in the direction of Earth's orbit around the Sun.
*/
const MOON = {
  SemiMajorAxis: toUnits(384821.4581097544), // in km
  EC: 0.05212487669881421,          // eccentricity
  IN: toRadians(5.280240463394533), // inclination relative to ecliptic
  OM: toRadians(347.9713278613414), // longitude of the Ascending Node
   W: toRadians(37.57619864565795), // argument of periapsis (perigee)
  MA: toRadians(352.7811711299613), // mean anomaly
};

// ============================================================================
// SCENE SETUP
// ============================================================================

/**
 * Creates a THREE.Line object representing a meridian (a line of longitude).
 * @param {number} radius The radius of the sphere the line should sit on.
 * @param {number} longitudeRad The longitude of the meridian in radians (0 for Prime Meridian).
 * @param {number} segments The number of segments to make the line smooth.
 * @param {number|string} color The color of the line.
 * @returns {THREE.Line} The created line object.
 */
function createMeridianLine(radius, longitudeRad = 0, segments = 64, color = 0xffff00) {
  const points = [];

  // Loop from North Pole to South Pole
  for (let i = 0; i <= segments; i++) {
    // Interpolate the latitude from +90 degrees to -90 degrees
    const latRad = Math.PI / 2 - (i / segments) * Math.PI;

    // Calculate the 3D position using spherical coordinates (with Y as up)
    const x = radius * Math.cos(latRad) * Math.cos(longitudeRad);
    const y = radius * Math.sin(latRad);
    const z = radius * Math.cos(latRad) * Math.sin(longitudeRad);

    points.push(new THREE.Vector3(x, y, z));
  }

  const geometry = new THREE.BufferGeometry().setFromPoints(points);
  const material = new THREE.LineBasicMaterial({ color: color, fog: false }); // fog:false keeps it visible from far away
  const line = new THREE.Line(geometry, material);

  return line;
}

// A small sphere at the clicked point
const marker = new THREE.Mesh(
  new THREE.SphereGeometry(0.1),
  new THREE.MeshBasicMaterial({ color: 0x00ff00 }) // Lime
);

// Create renderer and scene
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);
const scene = new THREE.Scene();
const cubeTextureLoader = new THREE.CubeTextureLoader();
scene.background = cubeTextureLoader.load(SKY_TEXTURE_URL);

// Ambient light for overall scene illumination
const ambientLight = new THREE.AmbientLight(0xffffff, 0.05); // White light, low intensity
scene.add(ambientLight);

// Directional light to simulate sunlight
const sunLight = new THREE.DirectionalLight(0xffffff, 1);
const sunDistance = toUnits(100 * MOON_DISTANCE_KM);
sunLight.position.set(sunDistance, 0, 0); // on the ecliptic plane
sunLight.lookAt(0, 0, 0);
scene.add(sunLight);

// Create camera
const camera = new THREE.PerspectiveCamera(
  45, // Field of view
  innerWidth / innerHeight, // Aspect ratio
  0.1,  // Near clipping plane
  10000 // Far clipping plane
);
const cameraDistance = toUnits(2 * MOON_DISTANCE_KM); // From Earth center
const cameraAzimuth = toRadians(180); // Degrees clockwise from +Z axis
const cameraElevation = toRadians(10); // Degrees above horizontal plane
camera.position.set(
  cameraDistance * Math.cos(cameraElevation) * Math.sin(cameraAzimuth), // x
  cameraDistance * Math.sin(cameraElevation),                           // y
  cameraDistance * Math.cos(cameraElevation) * Math.cos(cameraAzimuth)  // z
);
camera.lookAt(0, 0, 0); // Point camera at Earth center
scene.add(camera);

// Setup camera controls
const DEFAULT_MIN_DISTANCE = toUnits(1.2 * EARTH_RADIUS_KM);
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.minDistance = DEFAULT_MIN_DISTANCE;
controls.maxDistance = toUnits(50 * MOON_DISTANCE_KM);

// Store initial camera position and target
const initialCameraPosition = camera.position.clone();
const initialCameraTarget = controls.target.clone();

// Tracks state for camera lock-to-target behavior
const Lock = {
  active: false, // true when camera is locked to a target
  candidates: [], // objects that can be locked
  lockedObj: null, // object we currently track
  prevPosition: new THREE.Vector3(), // obj world position last frame
  prevOrientation: new THREE.Quaternion(), // obj world orientation last frame
  tempVec: new THREE.Vector3(), // helper to avoids re-allocations
  tempQuat: new THREE.Quaternion(), // helper quaternion
};

// Returns first clickable candidate under mouse, or null
function getClickedCandidate(mouseX, mouseY) {

  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  // Convert mouse position to normalized device coordinates (-1 to +1)
  mouse.x =  (mouseX / window.innerWidth)  * 2 - 1;
  mouse.y = -(mouseY / window.innerHeight) * 2 + 1;

  // Update the raycaster with the camera and mouse position
  raycaster.setFromCamera(mouse, camera);

  // Find intersections with candidates
  const intersects = raycaster.intersectObjects(Lock.candidates);
  if (intersects.length === 0)
    return null;

  return {
    object: intersects[0].object,
    point: intersects[0].point // point on the surface in world space
  };
}

function unlockCamera() {
  Lock.lockedObj.remove(marker);
  controls.minDistance = DEFAULT_MIN_DISTANCE;
  Lock.lockedObj = null;
  Lock.active = false;
}

// Locks the camera into a geostationary orbit around the selected object
function lockCameraTo(objectToLock, surfacePoint) {

  if (!objectToLock.geometry.parameters || objectToLock.geometry.parameters.radius === undefined) {
    console.error("Object to lock must be a THREE.Mesh with a THREE.SphereGeometry.");
    return;
  }

  Lock.active = true;
  Lock.lockedObj = objectToLock;

  // Initialize the "previous" world state
  Lock.lockedObj.getWorldPosition(Lock.prevPosition);
  Lock.lockedObj.getWorldQuaternion(Lock.prevOrientation);

  // Center camera on target for better UX (user can still pan after)
  const objCenter = Lock.prevPosition.clone();
  controls.target.copy(objCenter);
  const radius = Lock.lockedObj.geometry.parameters.radius
  controls.minDistance = radius * 1.2;

  // Reposition camera along center-surface vector, same distance
  const distanceToCenter = camera.position.distanceTo(objCenter);
  const direction = Lock.tempVec.subVectors(surfacePoint, objCenter).normalize();
  camera.position.copy(direction.multiplyScalar(distanceToCenter)).add(objCenter);

  // Show a marker on the clicked point
  marker.position.copy(surfacePoint);
  Lock.lockedObj.worldToLocal(marker.position);
  Lock.lockedObj.add(marker);

  controls.update();
}

function updateCameraLock() {

  console.assert(Lock.lockedObj, "Called update lock with no locked object");

  // Get current target transform
  const currentWorldPos = Lock.lockedObj.getWorldPosition(Lock.tempVec);
  const currentWorldQuat = Lock.lockedObj.getWorldQuaternion(Lock.tempQuat);

  // Compute transform delta since last frame
  const translationDelta = currentWorldPos.clone().sub(Lock.prevPosition);
  const rotationDelta = currentWorldQuat.clone().multiply(Lock.prevOrientation.clone().invert());

  // Cache current transform for next frame‚Äôs delta
  Lock.prevPosition.copy(currentWorldPos);
  Lock.prevOrientation.copy(currentWorldQuat);

  // Capture the camera's current relationship to its target (this preserves user input)
  const targetToCamera = camera.position.clone().sub(controls.target);

  // Apply rotation on the target-to-camera vector
  targetToCamera.applyQuaternion(rotationDelta);

  // Apply translation to target to preserve user pan
  controls.target.add(translationDelta);

  // Recompute camera position from updated target + preserved offset
  camera.position.copy(controls.target).add(targetToCamera);
}

function flipTarget() {
  if (!Lock.active)
    return;

  // Flip target 180¬∞: T' = C - (T - C)
  controls.target.sub(camera.position).negate().add(camera.position);
  controls.update();
}

// ============================================================================
// CELESTIAL BODY CREATION
// ============================================================================

/* WARNING: By default Three.js applies rotations in XYZ order. We use nested
   Object3D containers to apply rotations in a different order.

   Three.js coordinate system is XZ plane and +Y (UP) perpendicular direction
*/

// Computes an array of 3D vertex on an elliptic curve in XZ plane
function ellipticCurve(SemiMajorAxis, EC, W) {
  const SEGMENTS = 360;
  const positions = new Float32Array(SEGMENTS * 3);
  for (let i = 0; i < SEGMENTS; i++) {
    const ta = (i / SEGMENTS) * 2 * Math.PI; // true anomaly
    const angle = ta + W; // angle from ascending node
    const r = SemiMajorAxis * (1 - EC * EC) / (1 + EC * Math.cos(ta));
    positions[i*3 + 0] = r * Math.cos(angle); // x
    positions[i*3 + 1] = 0;                   // y  (on orbital plane)
    positions[i*3 + 2] = r * Math.sin(angle); // z
  }
  return positions;
}

// Create Earth hierarchy
// The innermost node performs daily rotations around pole axis
const textureLoader = new THREE.TextureLoader();
const earthTexture = textureLoader.load(EARTH_TEXTURE_URL);
const earth = new THREE.Mesh(
  new THREE.SphereGeometry(toUnits(EARTH_RADIUS_KM), 64, 64),
  new THREE.MeshStandardMaterial({ map: earthTexture, roughness: 0.8 })
);
Lock.candidates.push(earth);

// Add parent to tilt and rotate vertical axis for precession
const earthAxis = new THREE.Object3D();
// Set the Earth's obliquity (axial tilt).
// Our world coordinate system is Ecliptic in Three.js conventions:
// - Y-axis is the North Ecliptic Pole.
// - X-axis points towards the Vernal Equinox position.
//
// We want to model the seasons, so at the Northern Hemisphere's summer solstice,
// the North Pole must be tilted towards the Sun. We define this solstice
// to occur when the Sun is on the positive X-axis.
//
// A negative rotation around the Z-axis (by the right-hand rule) correctly
// tilts the Earth's North Pole (its local +Y) towards the world's +X axis.
earthAxis.rotation.z = -toRadians(EARTH_AXIAL_TILT);
earthAxis.add(earth);

// Create Moon hierarchy, each node performs at most one rotation
// Starting from the innermost node, the moon mesh that performs
// rotation around its axis. Texture map is already centered on
// 0¬∞ longitude.
const moonTexture = textureLoader.load(MOON_TEXTURE_URL);
const moon = new THREE.Mesh(
  new THREE.SphereGeometry(toUnits(MOON_RADIUS_KM), 32, 32),
  new THREE.MeshStandardMaterial({ map: moonTexture, roughness: 0.9 })
);

// Create a bright yellow line to represent the Prime Meridian (0¬∞ longitude).
// We make the radius slightly larger than the Earth's to prevent Z-fighting
// (where the line flickers because it's at the same depth as the texture).
const primeMeridianLine = createMeridianLine(toUnits(EARTH_RADIUS_KM) * 1.01);

// Add the line as a child of the Earth mesh. This ensures it inherits
// all of the Earth's rotations (both daily spin and axial tilt).
//earth.add(primeMeridianLine);

// Add parent to tilt and rotate vertical axis for precession
const moonAxis = new THREE.Object3D();
moonAxis.rotation.z = toRadians(MOON_AXIAL_TILT); // FIXME initial offset missing
moonAxis.add(moon);
Lock.candidates.push(moon);

// Add parent to set a fixed inclined orbital path, this is the target when setting
// current moon position in animation (through moonAxis object)
const moonOrbit = new THREE.Object3D();
moonOrbit.rotation.x = MOON.IN; // inclination to ecliptic
moonOrbit.add(moonAxis);

// Create an elliptical curve for the Moon's orbit in its orbital plane
const positions = ellipticCurve(MOON.SemiMajorAxis, MOON.EC, MOON.W)
const vertexBuffer = new THREE.BufferAttribute(positions, 3);
const orbitGeometry = new THREE.BufferGeometry().setAttribute('position', vertexBuffer);
const orbitMaterial = new THREE.LineBasicMaterial({
  color: 0x4488ff, // light blue
  transparent: true,
  opacity: 0.35
});
const orbitPath = new THREE.LineLoop(orbitGeometry, orbitMaterial);
moonOrbit.add(orbitPath);

// Add parent to follow the Moon's orbit nodal precession (swivel)
const ascendingNodePivot = new THREE.Object3D();
ascendingNodePivot.add(moonOrbit);

// Finally add Moon and Earth hierarchy to scene
scene.add(ascendingNodePivot);
scene.add(earthAxis);

// ============================================================================
// Kepler's Second Law Solver
// ============================================================================

/**
 * Solves Kepler's Equation M = E - e * sin(E) for the Eccentric Anomaly (E).
 * Uses the Newton-Raphson iterative method.
 *
 * @param {number} M - The Mean Anomaly in radians.
 * @param {number} e - The eccentricity of the orbit.
 * @returns {number} The Eccentric Anomaly (E) in radians.
 */
function solveKepler(M, e) {
  let E = M; // Initial guess for E is M
  const maxIterations = 10;
  const tolerance = 1e-6; // A small tolerance for accuracy

  for (let i = 0; i < maxIterations; i++) {
    const f = E - e * Math.sin(E) - M; // The function we want to find the root of
    const fPrime = 1 - e * Math.cos(E); // The derivative df/dE
    const deltaE = f / fPrime;

    E = E - deltaE; // New, better guess for E

    if (Math.abs(deltaE) < tolerance)
      break; // Solution is accurate enough
  }
  return E;
}

function getMoonPosition(elapsedTime) {

  // Calculate current Mean Anomaly (M) and Eccentric Anomaly (E)
  const n = -2 * Math.PI / MOON_ORBITAL_PERIOD; // Mean motion (rad/sec)
  const M = MOON.MA + n * elapsedTime; // Current Mean Anomaly
  const EC = MOON.EC;
  const E = solveKepler(M, EC); // Kepler's Second Law

  // Calculate the current True Anomaly (TA or ŒΩ), the real angle from perigee
  const [sinE, cosE] = [Math.sin(E), Math.cos(E)];
  const sinTA = Math.sqrt(1 - EC*EC) * sinE / (1 - EC * cosE);
  const cosTA = (cosE - EC) / (1 - EC * cosE);
  const TA = Math.atan2(sinTA, cosTA);

  // Calculate distance from Earth (focus)
  const r = MOON.SemiMajorAxis * (1 - EC * EC) / (1 + EC * Math.cos(TA));

  // Calculate position in the orbital plane
  const angleFromAscendingNode = TA + MOON.W; // x-axis is at ascending node
  const x = r * Math.cos(angleFromAscendingNode);
  const z = r * Math.sin(angleFromAscendingNode);
  return [x, 0, z]; // Return 3D coordinates (Y=0 in orbital plane)
}

// ============================================================================
// ANIMATION LOOP
// ============================================================================

// Calculate simulation constants and state
const earthRotationSpeed = 2 * Math.PI / EARTH_ROTATION_PERIOD;
const precessionSpeed = 2 * Math.PI / EARTH_PRECESSION_PERIOD;
const moonSiderealRotationSpeed = 2 * Math.PI / MOON_ORBITAL_PERIOD;
const moonNodeSpeed = 2 * Math.PI / MOON_NODE_PRECESSION_PERIOD;
const sunOrbitSpeed = 2 * Math.PI / SUN_ORBITAL_PERIOD;
const sunInitialAngle = (DAYS_SINCE_SOLSTICE / 365.25) * 2 * Math.PI;
const earthInitialAngle = 8 * 2 * Math.PI / 24; // FIXME

const clock = new THREE.Clock();
let isPlaying   = true;
let speed       = 1; // 1 = 1 sec real-time ‚Üî 1 h sim-time
let elapsedTime = 0; // 1 second real time = 1 hour sim time

// Animation loop function
function animate() {

  elapsedTime += (isPlaying ? speed : 0) * clock.getDelta();

  // Rotate Earth
  earth.rotation.y = earthInitialAngle  + elapsedTime * earthRotationSpeed;

  // Earth axial precession (at t = 0 inclination is aligned toward Sun at solstice)
  earthAxis.rotation.y = precessionSpeed * elapsedTime;

  // Moon rotation around its axis, in tidal locking with Earth
  // Offset 180-degree because texture is centered on 0¬∞ longitude (facing earth)
  moon.rotation.y = Math.PI + moonSiderealRotationSpeed * elapsedTime;

  // Moon orbit around Earth
  const [x, y, z] = getMoonPosition(elapsedTime);
  moonAxis.position.set(x, y, z);

  // The Moon's orbital plane precesses backwards (retrograde).
  // This is a rotation around the Ecliptic Pole (the Y-axis).
  ascendingNodePivot.rotation.y = MOON.OM - moonNodeSpeed * elapsedTime;

  // Simulate Sun's (circular) prograde orbit around Earth for lighting
  // The angle (=0 at summer solstice) increases for a counter-clockwise orbit
  const sunAngle = sunInitialAngle + elapsedTime * sunOrbitSpeed;
  sunLight.position.set(sunDistance * Math.cos(sunAngle), 0, sunDistance * Math.sin(sunAngle));

  if (Lock.active)
    updateCameraLock();

  // Update controls and render
  controls.update();
  updateDateTimeUI();
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

// ============================================================================
// UI CONTROLS
// ============================================================================

const dateInp  = document.getElementById('simDate');
const timeInp  = document.getElementById('simTime');
const elapsedS = document.getElementById('simElapsed');
const playBtn  = document.getElementById('btnPlay');
const revBtn   = document.getElementById('btnReverse');
const resBtn   = document.getElementById('btnReset');
const speedSl  = document.getElementById('speedSlider');
const speedOut = document.getElementById('speedOut');
const camRow   = document.getElementById('camRow');
const camStore = document.getElementById('camStore');
const camClose = document.getElementById('camClose');
const linkIcon = document.getElementById('linkIndicator');

const toDateStr = d => d.toISOString().slice(0, 10);
const toTimeStr = d => d.toISOString().slice(11, 19);

function updateDateTimeUI() {
  const elapsedMsec = elapsedTime * 3600 * 1000; // hours to ms
  const cur = new Date(REFERENCE_DATE.getTime() + elapsedMsec);
  dateInp.value = toDateStr(cur);
  timeInp.value = toTimeStr(cur);
  elapsedS.textContent = (elapsedTime / 24).toFixed(1)+' d';
}

function dateTimeChanged() {
  const d = new Date(dateInp.value+'T'+timeInp.value+'Z');
  elapsedTime = (d - REFERENCE_DATE) / (3600 * 1000);
  updateDateTimeUI();
}

function updateSpeedUI() {
  speedOut.textContent = (speed < 0?'‚àí':'') + Math.abs(speed).toFixed(1)+' √ó';
  const sliderValue = Math.sqrt(Math.abs(speed)); // power of 2 scaling
  speedSl.value = sliderValue;
  revBtn.textContent = speed < 0 ? '‚óÖ' : '‚ñª';
}

function speedChanged() {
  const sign = speed !== 0 ? Math.sign(speed) : 1; // keep sign
  const sliderValue = Number(speedSl.value);
  speed = sign * (sliderValue * sliderValue); // power of 2 scaling
  updateSpeedUI();
};

function sceneDoubleClicked(mouseX, mouseY) {
  const target = getClickedCandidate(mouseX, mouseY);
  if (!target)
    return;
  // Clicked again on the already locked object?
  if (Lock.active && target.object === Lock.lockedObj) {
    unlockCamera();
    linkIcon.classList.remove('active');
  } else {
    lockCameraTo(target.object, target.point);
    linkIcon.classList.add('active');
  }
};

dateInp.onchange = dateTimeChanged;
timeInp.onchange = dateTimeChanged;
speedSl.oninput = speedChanged;

playBtn.onclick = ()=>{
  isPlaying = !isPlaying;
  playBtn.textContent = isPlaying ? '‚è∏' : '‚ñ∂';
};

revBtn.onclick = ()=> {
  speed *= -1;
  revBtn.textContent = speed < 0 ? '‚óÖ' : '‚ñª';
  updateSpeedUI();
};

resBtn.onclick = ()=>{
  elapsedTime = 0;
  speed = 1;
  updateDateTimeUI();
  updateSpeedUI();

  camera.position.copy(initialCameraPosition);
  controls.target.copy(initialCameraTarget);
  controls.update();
};

const CAM_KEY = 'orbitCamSlots';
// Clear localStorage at startup (treat like session storage)
localStorage.removeItem(CAM_KEY);
let slots = [];
let pressedSlotIndex = null;
let clickTimer = null;

function setCameraView({pos, target}){
  camera.position.set(...pos);
  controls.target.set(...target);
  controls.update();
}

function CamBtnPressed(slotIndex) {
  pressedSlotIndex = slotIndex;
  clickTimer = Date.now(); // start timer for double-click detection
}

function CamBtnReleased(slotIndex) {

  const longClick = (Date.now() - clickTimer) > 400; // 400 ms threshold
  const sameBtn = pressedSlotIndex === slotIndex;
  pressedSlotIndex = null; // reset
  clickTimer = null;

  if (!sameBtn)
    return;

  // Long click: clear the slot
  if (longClick) {
    slots[slotIndex] = null;
    localStorage.setItem(CAM_KEY, JSON.stringify(slots));
    this.classList.remove('saved');
  } else {
    // Normal click: either save or restore camera
    // according if slot is empty or not
    const slot = slots[slotIndex];
    if (slot) {
      setCameraView(slot);
    } else {
      const slot = {
        pos: camera.position.toArray(),
        target: controls.target.toArray()
      };
      slots[slotIndex] = slot;
      localStorage.setItem(CAM_KEY, JSON.stringify(slots));
      this.classList.add('saved');
    }
  }
}

// Bind all camera buttons to click and double-click handlers
document.querySelectorAll('.camBtn').forEach((b,i)=>{
  b.onmousedown = CamBtnPressed.bind(b, i);
  b.onmouseup = CamBtnReleased.bind(b, i);
});

addEventListener('dblclick', (event) => {
  sceneDoubleClicked(event.clientX, event.clientY);
});

// Add keyboard listener for CTRL+F to flip 180 degrees controls target
addEventListener('keydown', (event) => {
  if (event.ctrlKey && event.key === 'f') {
    event.preventDefault(); // Prevent browser's default find functionality
    flipTarget();
  }
});

addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// Finally start animation
animate();

</script>
</body>
</html>
