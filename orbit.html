<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Earth–Moon System Visualization</title>
  <style>
    :root {
      /* Color definitions */
      --color-black: #000;
      --color-white: #fff;
      --color-primary: rgba(255,255,255,.12);
      --color-primary-hover: rgba(255,255,255,.25);
      --color-border: rgba(255,255,255,.35);
      --color-border-light: rgba(255,255,255,.25);
      --color-background: rgba(0,0,0,.35);
      --color-orbit: #4488ff;
    }
    body {
      margin: 0;
      overflow: hidden;
      background: var(--color-black);
    }
    #hud {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      color: var(--color-white);
      font: 14px/1.2 system-ui, sans-serif;
      pointer-events: none; /* let clicks pass through by default */
    }
    .hud__row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 12px;
      margin: 0 auto 4px auto;
      width: 96%;
      max-width: 900px;
      background: var(--color-background);
      backdrop-filter: blur(8px);
      border: 1px solid var(--color-border-light);
      border-radius: 8px;
      pointer-events: auto;
    }
    .hud__group { display: flex; align-items: center; gap: 8px; }
    input, button {
      font: inherit; color: inherit; background: var(--color-primary);
      border: 1px solid var(--color-border);
      border-radius: 4px; padding: 4px 6px;
    }
    button { cursor: pointer; min-width: 32px; }
    button:hover { background: var(--color-primary-hover); }
    input[type=range] { width: 90px; accent-color: var(--color-primary); background: var(--color-primary); }
    #speedOut { width: 58px; text-align: right; }
    /* camera row */
    .hud__cam { justify-content: flex-start; gap: 6px; }
    .camBtn { width: 32px; }
    #camStore { margin-left: auto; margin-right: 6px; }
    #camClose { background: none; border: none; opacity: .7; }
  </style>
</head>
<body>
<div id="hud">
  <div class="hud__row hud__main">
    <!-- LEFT -->
    <div class="hud__group">
      <label title="Date / Time (UTC+2)">
        <input id="simDate" type="date">
        <input id="simTime" type="time" step="60">
      </label>
      <span id="simElapsed">+0.0 d</span>
    </div>

    <!-- CENTRE -->
    <div class="hud__group">
      <button id="btnReverse" aria-label="Reverse time">▻</button>
      <button id="btnPlay"   aria-label="Play/Pause">⏸</button>
      <button id="btnReset"  aria-label="Reset">⟲</button>
    </div>

    <!-- RIGHT -->
    <div class="hud__group">
      <input id="speedSlider" type="range" min="0" max="10" step="1" value="1">
      <output id="speedOut" for="speedSlider">1 ×</output>
    </div>
  </div>

  <!-- Second row: camera snapshots -->
  <div class="hud__row hud__cam" id="camRow" hidden>
    <button class="camBtn" data-slot="1">1</button>
    <button class="camBtn" data-slot="2">2</button>
    <button class="camBtn" data-slot="3">3</button>
  </div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "orbitControls": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js"
  }
}
</script>

<script type="module">

/*
  TODO:
    - highlight orbital nodes, perigee, apogee
    - Add stars background
*/

import * as THREE from 'three';
import { OrbitControls } from 'orbitControls';

// ============================================================================
// CONSTANTS AND HELPER FUNCTIONS
// ============================================================================

const EARTH_TEXTURE_URL = 'textures/earth_atmos_2048.jpg';
const MOON_TEXTURE_URL = 'textures/moon_1024.jpg';
const SKY_TEXTURE_URL = [  // In celestial coordinates from https://svs.gsfc.nasa.gov/4851
    'textures/sky_px.png', // Right
    'textures/sky_nx.png', // Left
    'textures/sky_py.png', // Top
    'textures/sky_ny.png', // Bottom
    'textures/sky_pz.png', // Front
    'textures/sky_nz.png'  // Back
];

// Scale conversion constants
const KM_PER_UNIT = 1200; // Earth radius is ~5.3 units in this scale
const toUnits = km => km / KM_PER_UNIT;
const toRadians = degrees => degrees * Math.PI / 180;

// Physical properties (in kilometers, converted to scene units)
const EARTH_RADIUS_KM = 6371 * 4; // Scaled up for visibility
const MOON_RADIUS_KM = 1737 * 4;
const MOON_DISTANCE_KM = 384400;
const EARTH_AXIAL_TILT = 23.44; // degrees
const MOON_AXIAL_TILT = 6.68; // degrees

// Time constants for simulation
const SIMULATION_HOUR = 1; // 1 second of real time represents 1 hour in simulation
const SIMULATION_DAY = 24 * SIMULATION_HOUR;
const SIMULATION_YEAR = 365.25 * SIMULATION_DAY;
const MOON_ORBITAL_PERIOD = 27.55455 * SIMULATION_DAY; // anomalistic period
const EARTH_ROTATION_PERIOD = 23.93447 * SIMULATION_HOUR; // sidereal day
const SUN_ORBITAL_PERIOD = 365.25 * SIMULATION_DAY; // sidereal year
const MOON_NODE_PRECESSION_PERIOD = 18.613 * SIMULATION_YEAR; // Cassini-state orientation

// Helpers to calculate date differences
function daysSinceStartOfYear(targetDate) {
  const year = targetDate.getFullYear();
  const startOfYear = new Date(year, 0, 1); // Months are 0-indexed, so 0 = January
  return (targetDate - startOfYear) / (1000 * 60 * 60 * 24); // Convert milliseconds to days
}

// Our reference date is September 10, 2025
const REFERENCE_DATE = new Date('2025-09-10T00:00:00Z');
const DAYS_SINCE_SOY = daysSinceStartOfYear(REFERENCE_DATE);

// ============================================================================
// ORBITAL MECHANICS SETUP
// ============================================================================

// Returns the quaternion that implements the ZXZ rotation sequence given the
// Euler extrinsic angles. ZXZ rotation can reach any target orientation in 3D space.
// Rotations are counter-clockwise according to the right-hand rule.
function ZXZSequence(alpha, beta, gamma) {

  // Define the Z and X axis of the initial frame according to THREE conventions
  const x_axis = new THREE.Vector3(1, 0, 0);
  const z_axis = new THREE.Vector3(0, 0, 1);

  // Define one quaternion (axis + rotation angle) for each rotation
  const rzA = new THREE.Quaternion().setFromAxisAngle(z_axis, alpha);
  const rxB = new THREE.Quaternion().setFromAxisAngle(x_axis, beta);
  const rzG = new THREE.Quaternion().setFromAxisAngle(z_axis, gamma);

  // In Three.js Quaternion multiplication applies rotations from
  // right to left and assumes angles to be intrinsic:
  //
  //   multiply(P).multiply(Q) == P * Q -> apply first rotation Q then P
  //
  // Our angles α, β, γ are instead extrinsic (refer all to fixed initial
  // frame), so we use this equivalence:
  //
  //       G * B * A (extrinsic) === A * B * G (intrinsic)
  //
  // To rotate first by alpha, then by beta, then by gamma the combined ZXZ rotation
  // is (G * B * A), but THREE.multiply() assumes angles to be intrinsic, so we have
  // to compute (A * B * G) instead.
  //
  // Compute the orientation of the final frame relative to the initial frame
  // (quaternion rotates the *frame*, not the vector).
  const InitialToFinal = new THREE.Quaternion().multiply(rzA).multiply(rxB).multiply(rzG);

  // The quaternion that rotates a *vector* from initial frame to final frame
  // is the inverse of the frame rotation.
  const R = InitialToFinal.clone().invert();

  return R;
}

// Compute initial orbital parameters
function initOrbitalParameters() {
  /*
    Init all orbital parameters out of JPL Horizons data for September 10, 2025
    https://ssd.jpl.nasa.gov/horizons/app.html

    Reference frame : Ecliptic of J2000.0

    Origin: The center of the Earth

    Fundamental Plane: The Earth's mean orbital plane (the ecliptic) as it was at the J2000.0 epoch.

    Z-axis: A line perpendicular to this ecliptic plane, pointing north.

    X-axis: This primary direction points towards the vernal equinox, the point where the Sun crosses
            the celestial equator from south to north—as it was at the J2000.0 epoch.

    Y-axis: 90° ahead of the X-axis in the direction of Earth's orbit around the Sun.
  */

  // Orbital elements for the Moon at reference date
  const EC = 0.05212487669881421; // eccentricity
  const A  = 384821.4581097544;   // semi-major axis (km)
  const IN = toRadians(5.280240463394533); // inclination relative to ecliptic
  const OM = toRadians(347.9713278613414); // longitude of the Ascending Node
  const W  = toRadians(37.57619864565795); // argument of periapsis (perigee)
  const MA = toRadians(352.7811711299613); // mean anomaly

  // Ecliptic vector (km) for the Moon
  const Xe = 3.087382089986445e5; // X pointing towards vernal equinox
  const Ye = 1.931385895910154e5; // Y 90° ahead in orbit
  const Ze = 2.340431283250813e4; // Z perpendicular to ecliptic plane

  // Change vector coordinates from Ecliptic into the Moon's orbital plane
  // (perifocal frame) with a ZXZ extrinsic (fixed-axis) rotation.
  // 1. Rotation of Ω around z-axis (UP) aligns x-axis with Moon orbit Ascending Node
  // 2. Rotation of IN around x-axis tilts the vector
  // 3. Rotation of W z-axis aligns x-axis with perigee
  const EclipticToMoon = ZXZSequence(OM, IN, W);

  // Apply rotation to get the Moon vector in Moon's orbital plane coordinates
  const Ve = new THREE.Vector3(Xe, Ye, Ze);
  const Vm = Ve.clone().applyQuaternion(EclipticToMoon);
  const Xp = Vm.x; // towards the Moon's perigee
  const Yp = Vm.y; // 90° ahead in the direction of Moon's motion
  const Zp = Vm.z; // perpendicular to the orbital plane (should be ~0)

  console.assert(Math.abs(Zp) < 0.1, `Zp should be ~0 in Moon's orbital plane, got ${Zp}`);

  // Calculate the true anomaly (angle from perigee)
  const trueAnomaly = Math.atan2(Yp, Xp);

  // Calculate the argument of latitude (angle from ascending node)
  const argumentOfLatitude = trueAnomaly + W;

  // Calculate ellipse geometry
  const semiMajorAxis = toUnits(A);
  const semiMinorAxis = semiMajorAxis * Math.sqrt(1 - EC * EC);

  // Compute the Eccentric, and Mean anomaly
  const cosE0 = (EC + Math.cos(trueAnomaly)) / (1 + EC * Math.cos(trueAnomaly));
  const sinE0 = Math.sqrt(1 - EC*EC) * Math.sin(trueAnomaly) / (1 + EC * Math.cos(trueAnomaly));
  const E0 = Math.atan2(sinE0, cosE0); // Eccentric Anomaly
  const meanAnomaly = E0 - EC * Math.sin(E0); // Kepler's Second Law

  return [OM, IN, W, toUnits(A), EC, MA]; // Use JPL data
}

const [MoonOrbRA, MoonOrbInclination, PerigeeAngle, semiMajorAxis, EC, initialMeanAnomaly] = initOrbitalParameters();

// ============================================================================
// SCENE SETUP
// ============================================================================

// Create renderer and scene
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);
const scene = new THREE.Scene();
const cubeTextureLoader = new THREE.CubeTextureLoader();
scene.background = cubeTextureLoader.load(SKY_TEXTURE_URL);

// Ambient light for overall scene illumination
const ambientLight = new THREE.AmbientLight(0xffffff, 0.05); // White light, low intensity
scene.add(ambientLight);

// Directional light to simulate sunlight
const sunLight = new THREE.DirectionalLight(0xffffff, 1);
const sunDistance = toUnits(100 * MOON_DISTANCE_KM);
sunLight.position.set(sunDistance, 0, 0); // on the ecliptic plane
sunLight.lookAt(0, 0, 0);
scene.add(sunLight);

// Create camera
const camera = new THREE.PerspectiveCamera(
  45, // Field of view
  innerWidth / innerHeight, // Aspect ratio
  0.1,  // Near clipping plane
  10000 // Far clipping plane
);
const cameraDistance = toUnits(2 * MOON_DISTANCE_KM); // From Earth center
const cameraAzimuth = toRadians(180); // Degrees clockwise from +Z axis
const cameraElevation = toRadians(10); // Degrees above horizontal plane
camera.position.set(
  cameraDistance * Math.cos(cameraElevation) * Math.sin(cameraAzimuth), // x
  cameraDistance * Math.sin(cameraElevation),                           // y
  cameraDistance * Math.cos(cameraElevation) * Math.cos(cameraAzimuth)  // z
);
camera.lookAt(0, 0, 0); // Point camera at Earth center

// Setup camera controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.minDistance = toUnits(2 * EARTH_RADIUS_KM); // From Earth center
controls.maxDistance = toUnits(50 * MOON_DISTANCE_KM);

// Store initial camera position and target
const initialCameraPosition = camera.position.clone();
const initialCameraTarget = controls.target.clone();

// ============================================================================
// CELESTIAL BODY CREATION
// ============================================================================

/* WARNING: By default Three.js applies rotations in XYZ order. At render time, it
  constructs a single rotation matrix like:

    M = RotateX(rotation.x) * RotateY(rotation.y) * RotateZ(rotation.z)

  To avoid gimbal lock, we use nested Object3D containers to apply rotations
  in a different order.
*/

// Create the Moon's orbital plane with nested objects to handle rotations
// Create an object that handles the longitude of the ascending node (RA)
const nodeObject = new THREE.Object3D();
nodeObject.rotation.y = MoonOrbRA; // rotation around the 'up' axis (Y)
scene.add(nodeObject);

// Create an object for the orbit inclination
const inclinationObject = new THREE.Object3D();
inclinationObject.rotation.x = MoonOrbInclination; // rotation around the NEW x-axis
nodeObject.add(inclinationObject);

// Create a 2D elliptical curve for the Moon's orbit in its orbital plane
const SEGMENTS = 360;
const positions = new Float32Array(SEGMENTS * 3);
for (let i = 0; i < SEGMENTS; i++) {
  const ta = (i / SEGMENTS) * 2 * Math.PI; // true anomaly
  const angle = ta + PerigeeAngle;         // angle from node
  const r = semiMajorAxis * (1 - EC * EC) / (1 + EC * Math.cos(ta));
  positions[i*3 + 0] = r * Math.cos(angle); // x
  positions[i*3 + 1] = 0;                   // y  (on orbital plane)
  positions[i*3 + 2] = r * Math.sin(angle); // z
}
const vertexBuffer = new THREE.BufferAttribute(positions, 3);
const orbitGeometry = new THREE.BufferGeometry().setAttribute('position', vertexBuffer);
const orbitMaterial = new THREE.LineBasicMaterial({
  color: 0x4488ff, // light blue
  transparent: true,
  opacity: 0.35
});
const orbitLine = new THREE.LineLoop(orbitGeometry, orbitMaterial);
inclinationObject.add(orbitLine);

// Create Moon
const textureLoader = new THREE.TextureLoader();

const moonAxis = new THREE.Object3D();
moonAxis.rotation.z = -toRadians(MOON_AXIAL_TILT);
inclinationObject.add(moonAxis);
const moonTexture = textureLoader.load(MOON_TEXTURE_URL);
const moon = new THREE.Mesh(
  new THREE.SphereGeometry(toUnits(MOON_RADIUS_KM), 32, 32),
  new THREE.MeshStandardMaterial({ map: moonTexture, roughness: 0.9 })
);
moonAxis.add(moon);

// Create Earth
const earthAxis = new THREE.Object3D();
earthAxis.rotation.z = -toRadians(EARTH_AXIAL_TILT);
scene.add(earthAxis);
const earthTexture = textureLoader.load(EARTH_TEXTURE_URL);
const earth = new THREE.Mesh(
  new THREE.SphereGeometry(toUnits(EARTH_RADIUS_KM), 64, 64),
  new THREE.MeshStandardMaterial({ map: earthTexture, roughness: 0.8 })
);
earthAxis.add(earth);

// ============================================================================
// Kepler's Second Law Solver
// ============================================================================

/**
 * Solves Kepler's Equation M = E - e * sin(E) for the Eccentric Anomaly (E).
 * Uses the Newton-Raphson iterative method.
 *
 * @param {number} M - The Mean Anomaly in radians.
 * @param {number} e - The eccentricity of the orbit.
 * @returns {number} The Eccentric Anomaly (E) in radians.
 */
function solveKepler(M, e) {
  let E = M; // Initial guess for E is M
  const maxIterations = 10;
  const tolerance = 1e-6; // A small tolerance for accuracy

  for (let i = 0; i < maxIterations; i++) {
    const f = E - e * Math.sin(E) - M; // The function we want to find the root of
    const fPrime = 1 - e * Math.cos(E); // The derivative df/dE
    const deltaE = f / fPrime;

    E = E - deltaE; // New, better guess for E

    if (Math.abs(deltaE) < tolerance)
      break; // Solution is accurate enough
  }
  return E;
}

function getMoonPosition(elapsedTime) {

  // Calculate current Mean Anomaly (M) and Eccentric Anomaly (E)
  const n = -2 * Math.PI / MOON_ORBITAL_PERIOD; // Mean motion (rad/sec)
  const M = initialMeanAnomaly + n * elapsedTime; // Current Mean Anomaly
  const E = solveKepler(M, EC); // Kepler's Second Law

  // Calculate the current True Anomaly (TA or ν), the real angle from perigee
  const [sinE, cosE] = [Math.sin(E), Math.cos(E)];
  const sinTA = Math.sqrt(1 - EC*EC) * sinE / (1 - EC * cosE);
  const cosTA = (cosE - EC) / (1 - EC * cosE);
  const TA = Math.atan2(sinTA, cosTA);

  // Calculate distance from Earth (focus)
  const r = semiMajorAxis * (1 - EC * EC) / (1 + EC * Math.cos(TA));

  // Calculate position in the orbital plane
  const angleFromAscendingNode = TA + PerigeeAngle; // x-axis is at ascending node
  const x = r * Math.cos(angleFromAscendingNode);
  const z = r * Math.sin(angleFromAscendingNode);
  return [x, 0, z]; // Return 3D coordinates (Y=0 in orbital plane)
}

// ============================================================================
// ANIMATION LOOP
// ============================================================================

// Calculate simulation constants and state
const earthRotationSpeed = 2 * Math.PI / EARTH_ROTATION_PERIOD;
const sunOrbitSpeed = 2 * Math.PI / SUN_ORBITAL_PERIOD;
const moonSiderealRotationSpeed = 2 * Math.PI / MOON_ORBITAL_PERIOD;
const moonNodeSpeed = 2 * Math.PI / MOON_NODE_PRECESSION_PERIOD;
const sunInitialAngle = (DAYS_SINCE_SOY / 365.25) * 2 * Math.PI;

const clock = new THREE.Clock();
const TZ_OFFSET = 2; // UTC+2
let isPlaying   = true;
let speed       = 1; // 1 = 1 sec real-time ↔ 1 h sim-time
let elapsedTime = 0; // 1 second real time = 1 hour sim time

// Animation loop function
function animate() {

  elapsedTime += (isPlaying ? speed : 0) * clock.getDelta();

  // Rotate Earth
  earth.rotation.y = elapsedTime * earthRotationSpeed + Math.PI;

  // Orbit Moon around Earth
  const [x, y, z] = getMoonPosition(elapsedTime);
  moonAxis.position.set(x, y, z);

  // The Moon's orbital plane precesses backwards (retrograde).
  // This is a rotation around the Ecliptic Pole (the Y-axis).
  nodeObject.rotation.y = MoonOrbRA - (moonNodeSpeed * elapsedTime);

  // Moon rotation, add 180-degree because Moon texture
  // is centered on 0° longitude (facing earth)
  moon.rotation.y = moonSiderealRotationSpeed * elapsedTime - Math.PI/4 + Math.PI; // in tidal locking

  // Simulate Sun's (circular) orbit around Earth (for lighting)
  const sunAngle = sunInitialAngle - elapsedTime * sunOrbitSpeed; // FIXME
  sunLight.position.set(sunDistance * Math.cos(sunAngle), 0, sunDistance * Math.sin(sunAngle));

  // Update controls and render
  controls.update();
  updateDateTimeUI();
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

// ============================================================================
// UI CONTROLS
// ============================================================================

const dateInp  = document.getElementById('simDate');
const timeInp  = document.getElementById('simTime');
const elapsedS = document.getElementById('simElapsed');
const playBtn  = document.getElementById('btnPlay');
const revBtn   = document.getElementById('btnReverse');
const resBtn   = document.getElementById('btnReset');
const speedSl  = document.getElementById('speedSlider');
const speedOut = document.getElementById('speedOut');
const camRow   = document.getElementById('camRow');
const camStore = document.getElementById('camStore');
const camClose = document.getElementById('camClose');

const toDateStr = d => d.toISOString().slice(0, 10);
const toTimeStr = d => d.toISOString().slice(11, 19);

function updateDateTimeUI() {
  const elapsedMsec = elapsedTime * 3600 * 1000; // hours to ms
  const cur = new Date(REFERENCE_DATE.getTime() + elapsedMsec);
  dateInp.value = toDateStr(cur);
  timeInp.value = toTimeStr(cur);
  elapsedS.textContent = (elapsedTime / 24).toFixed(1)+' d';
}

function dateTimeChanged() {
  const d = new Date(dateInp.value+'T'+timeInp.value+'Z');
  elapsedTime = (d - REFERENCE_DATE) / (3600 * 1000);
  console.log({d, elapsedTime});
  updateDateTimeUI();
}

function updateSpeedUI() {
  speedOut.textContent = (speed < 0?'−':'') + Math.abs(speed).toFixed(1)+' ×';
  const sliderValue = Math.sqrt(Math.abs(speed)); // power of 2 scaling
  speedSl.value = sliderValue;
  revBtn.textContent = speed < 0 ? '◅' : '▻';
}

function speedChanged() {
  const sign = speed !== 0 ? Math.sign(speed) : 1; // keep sign
  const sliderValue = Number(speedSl.value);
  speed = sign * (sliderValue * sliderValue); // power of 2 scaling
  updateSpeedUI();
};

dateInp.onchange = dateTimeChanged;
timeInp.onchange = dateTimeChanged;
speedSl.oninput = speedChanged;

playBtn.onclick = ()=>{
  isPlaying = !isPlaying;
  playBtn.textContent = isPlaying ? '⏸' : '▶';
};

revBtn.onclick = ()=> {
  speed *= -1;
  revBtn.textContent = speed < 0 ? '◅' : '▻';
  updateSpeedUI();
};

resBtn.onclick = ()=>{
  elapsedTime = 0;
  speed = 1;
  updateDateTimeUI();
  updateSpeedUI();

  camera.position.copy(initialCameraPosition);
  controls.target.copy(initialCameraTarget);
  controls.update();
};

const CAM_KEY = 'orbitCamSlots';
let slots = JSON.parse(localStorage.getItem(CAM_KEY) || '[]');
let pressedSlotIndex = null;
let clickTimer = null;

function setCameraView({pos, target}){
  camera.position.set(...pos);
  controls.target.set(...target);
  controls.update();
}

function CamBtnPressed(slotIndex) {
  pressedSlotIndex = slotIndex;
  clickTimer = Date.now(); // start timer for double-click detection
}

function CamBtnReleased(slotIndex) {

  const longClick = (Date.now() - clickTimer) > 400; // 400 ms threshold
  const sameBtn = pressedSlotIndex === slotIndex;
  pressedSlotIndex = null; // reset
  clickTimer = null;

  if (!sameBtn)
    return;

  // Long click: clear the slot
  if (longClick) {
    slots[slotIndex] = null;
    localStorage.setItem(CAM_KEY, JSON.stringify(slots));
    this.style.opacity = '.35';
  } else {
    // Normal click: either save or restore camera
    // according if slot is empty or not
    const slot = slots[slotIndex];
    if (slot) {
      setCameraView(slot);
    } else {
      const slot = {
        pos: camera.position.toArray(),
        target: controls.target.toArray()
      };
      slots[slotIndex] = slot;
      localStorage.setItem(CAM_KEY, JSON.stringify(slots));
      this.style.opacity = '1';
    }
  }
}

// Bind all camera buttons to click and double-click handlers
document.querySelectorAll('.camBtn').forEach((b,i)=>{
  b.onmousedown = CamBtnPressed.bind(b, i);
  b.onmouseup = CamBtnReleased.bind(b, i);
});

addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// Finally start animation
animate();

</script>
</body>
</html>
