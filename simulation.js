'use strict';

/*
  TODO:
    - When locked reset return to "at lock time" position
    - Show sun/raise events with a fading side legend
*/


/*
    Ecliptic J2000 Frame according to the International Celestial Reference System (ICRS)

    J2000 Frame uses a standard heliocentric, right-handed coordinate system to
    model the Solar System's geometry.

    EPOCH (J2000.0):
        The reference frame is fixed to a specific moment: January 1, 2000, at 12:00
        Terrestrial Time (TT), which is Julian Date 2451545.0 TT.

    ORIGIN:
        The formal origin (0,0,0) is the Barycenter of the Solar System

    THE FUNDAMENTAL PLANE (THE XY PLANE):
        This is the Earth's mean orbital plane as it existed at the J2000.0 epoch,
        also known as the "Ecliptic of J2000.0".
        - SIMPLIFICATION: We assume this plane is fixed and does not change over time.

    AXES DEFINITION:
      +X Axis: Points from the Sun towards the Vernal Equinox as it was at the J2000.0
               epoch. This is the principal direction of the reference frame.

      +Z Axis: Points towards the North Ecliptic Pole at the J2000.0 epoch. It is
               perpendicular to the XY plane, with its direction given by the right-hand
               rule (curling fingers in the direction of Earth's orbit makes the
               thumb point towards +Z).

      +Y Axis: Completes the right-handed coordinate system (X × Y = Z). This axis
               points towards the Summer Solstice direction. At the Vernal Equinox,
               the +Y axis has same direction as Earth's velocity.

   In this simulation we use a Geocentric Ecliptic coordinate system (referred as
   World Coordinates) adapted to Three.js conventions:

   ORIGIN: The formal origin (0,0,0) is the Earth center

   +X Axis: Parallel and with OPPOSITE direction of +X Axis in J2000 Frame, i.e. at
            J2000.0 Vernal Equinox it points from Earth toward Sun.

   +Y Axis: Parallel and with same direction of +Z Axis in J2000 Frame (UP)

   +Z Axis: Completes the right-handed coordinate system of Three.js (X × Y = Z where
            X is toward left, Y up and Z toward the screen). Parallel and with
            same direction to +Y axis in the Ecliptic J2000 Frame.

  Because UP axes +Y/+Z have same direction, due to right-hand-rule for rotations,
  a physical rotation of the Earth by an angle 'alpha' around the Sun in the
  heliocentric J2000 frame is mathematically equivalent to a rotation of the
  Sun by the same angle 'alpha' around the Earth in our geocentric World frame.
*/

import * as THREE from 'three';
import { ViewManager } from './view.js';

const EARTH_TEXTURE_URL = 'textures/earth_atmos_2048.jpg';
const MOON_TEXTURE_URL = 'textures/moon_1024.jpg';
const SKY_TEXTURE_URL = [  // In celestial coordinates from https://svs.gsfc.nasa.gov/4851
    'textures/sky_px.png', // Right
    'textures/sky_nx.png', // Left
    'textures/sky_py.png', // Top
    'textures/sky_ny.png', // Bottom
    'textures/sky_pz.png', // Front
    'textures/sky_nz.png'  // Back
];

// Physical properties (in kilometers, converted to scene units)
const EARTH_RADIUS_KM = 6371; // Conventional radius for sphere approx.
const MOON_RADIUS_KM = 1737.53;
const MOON_DISTANCE_KM = 384400;    // average
const EARTH_AXIAL_TILT = 23.439291; // degrees
const MOON_AXIAL_TILT = 6.68;       // degrees

// Scale conversions
const KM_PER_UNIT = EARTH_RADIUS_KM / 50; // Earth radius to units
const toUnits = km => km / KM_PER_UNIT;
const toRadians = degrees => degrees * Math.PI / 180;
const HMSToRadians = s => s.split(/\s+/).reduce((acc, v, i) => acc + parseFloat(v) / [1, 60, 3600][i], 0) * (Math.PI / 12);

// Time constants for simulation
const SIM_TIME_SPEED_UP = 60; // 1 simulation hour elapses in 1 minute

// Master Epoch of JPL data sources
const MASTER_EPOCH = new Date('2025-09-10T09:34:03Z');

const HOUR = 3600; // In SI seconds
const SOLAR_DAY = 24 * HOUR; // Mean Solar Day
const JULIAN_YEAR = 365.25 * SOLAR_DAY;

const SIDERAL_DAY = 23.9344696 * HOUR; // Period of a 360 degrees rotation
const SIDEREAL_YEAR = 365.256363004 * SOLAR_DAY; // For epoch J2000.0

const EARTH_PRECESSION_PERIOD = 25772 * JULIAN_YEAR;
const MOON_NODE_PRECESSION_PERIOD = 18.612815932 * JULIAN_YEAR;

// Standard atmospheric refraction in arcminutes
const HORIZON_REFRACTION = toRadians(34.5 / 60);

/*
    Moon and Earth Ephemeris from JPL Horizons

    https://ssd.jpl.nasa.gov/horizons/app.html

    The raw `DATA` values (IN, OM, W, etc.) were generated by JPL Horizons
    using a GEOCENTRIC reference frame for Moon and heliocentric for Earth.
    The values are referenced to the Ecliptic and Mean Equinox of J2000.

    The simulation uses a nested hierarchy of Object3D nodes to build the Moon's
    orbit around a fixed Earth at (0,0,0). The final, outermost coordinate system
    (defined by the `moonOrbit` object) has the following properties:

    - ORIGIN: The center of the Earth.

    - FUNDAMENTAL PLANE: The local XZ plane of the `moonOrbit` object represents
      the Moon's own orbital plane.

    - LOCAL +X AXIS: This is the principal direction, defined as the "line of nodes".
      It points from the Earth towards the Ascending Node of the Moon's orbit.

    - LOCAL +Y AXIS: Perpendicular to the Moon's orbital plane, pointing towards
      the Moon's orbital north pole. Moon orbits in counter-clockwise direction,
      so with positive angle, around this axis.

    - LOCAL +Z AXIS: Completes the right-handed system (X × Y = Z). In particular
      when Moon is at Ascending Node, the Moon's velocity vector is perpendicular
      to X-axis and the +Z axis is in the OPPOSITE direction of Moon orbit direction.

    Key differences compared with JPL ephemeris source data are:

    - "UP" AXIS: The simulation's geocentric frame uses the Ecliptic North Pole as
      its primary +Y ("Up") axis. The Moon's orbital plane is inclined relative to
      this. The JPL frame uses +Z as the Ecliptic North Pole.

    - PRINCIPAL DIRECTION: The simulation's local frame uses the Ascending Node
      as its +X axis. The JPL frame uses the J2000 Vernal Equinox as its +X axis.
      The simulation applies the "Longitude of the Ascending Node" (`OM`) as a
      rotation around the Ecliptic Pole (+Y) to correctly orient our local
      frame's +X axis relative to the Vernal Equinox.
*/

const MOON_DATA = {
     A: toUnits(3.848214581097544E+05),   // km (Semi-major Axis)
    EC: 5.212487669881421E-02,            // eccentricity
    IN: toRadians(5.280240463394533E+00), // inclination relative to ecliptic
    OM: toRadians(3.479713278613414E+02), // longitude of the Ascending Node
     W: toRadians(3.757619864565795E+01), // argument of periapsis (perigee)
    MA: toRadians(7.092828128683312E+00), // mean anomaly
    PR: 2.348608891413124E+06,            // orbital period in seconds
};

const EARTH_DATA = {
     A: toUnits(1.494830834194617E+08),
    EC: 1.676617060159998E-02,
    IN: toRadians(5.309273646886771E-03),
    OM: toRadians(1.712802847305776E+02),
     W: toRadians(2.944120698115610E+02),
    MA: toRadians(2.435990102008265E+02),
    PR: 3.152183743256430E+07,

    L_Ap_Sid_Time: HMSToRadians("08 52 45.4526"), // Greenwich Apparent Sidereal Time (GAST)
};

// ============================================================================
// SCENE SETUP
// ============================================================================

// Create renderer and scene
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight); // Full viewport
document.body.appendChild(renderer.domElement);
const cubeTextureLoader = new THREE.CubeTextureLoader();
const scene = new THREE.Scene();
scene.background = cubeTextureLoader.load(SKY_TEXTURE_URL);

// Ambient light for overall scene illumination
const ambientLight = new THREE.AmbientLight(0xffffff, 0.05); // White light, low intensity
scene.add(ambientLight);

// Directional light to simulate sunlight
const sunLight = new THREE.DirectionalLight(0xffffff, 1);
sunLight.position.set(1, 0, 0); // just for setting target with lookAt() FIXME remove
sunLight.lookAt(0, 0, 0);
scene.add(sunLight);

// Initial camera view that is also the default one
const defaultCameraPos = (function() {
  const cameraDistance = toUnits(2 * MOON_DISTANCE_KM); // From Earth center
  const cameraAzimuth = toRadians(180);  // Degrees clockwise from +Z axis
  const cameraElevation = toRadians(10); // Degrees above horizontal plane
  return new THREE.Vector3(
    cameraDistance * Math.cos(cameraElevation) * Math.sin(cameraAzimuth),
    cameraDistance * Math.sin(cameraElevation),
    cameraDistance * Math.cos(cameraElevation) * Math.cos(cameraAzimuth)
  );
})();
const views = new ViewManager(scene, renderer, defaultCameraPos);


// Earth hierarchy
//
// The innermost node performs daily rotation around its pole axis
const textureLoader = new THREE.TextureLoader();
const earthTexture = textureLoader.load(EARTH_TEXTURE_URL);
const earth = new THREE.Mesh(
  new THREE.SphereGeometry(toUnits(EARTH_RADIUS_KM), 64, 64),
  new THREE.MeshStandardMaterial({ map: earthTexture, roughness: 0.8 })
);

// Add a parent to tilt vertical axis and slowly rotate it for precession
const tiltedEarth = new THREE.Object3D();
tiltedEarth.add(earth);

// Add Earth hierarchy to the scene
scene.add(tiltedEarth);


// Moon hierarchy
//
// The innermost node performs rotation around its pole axis
const moonTexture = textureLoader.load(MOON_TEXTURE_URL);
const moon = new THREE.Mesh(
  new THREE.SphereGeometry(toUnits(MOON_RADIUS_KM), 32, 32),
  new THREE.MeshStandardMaterial({ map: moonTexture, roughness: 0.9 })
);

// Add a parent to tilt vertical axis and rotate it for precession
const tiltedMoon = new THREE.Object3D();
tiltedMoon.add(moon);

// Add parent to set a fixed inclined orbital path, this is the target
// when setting current moon position in animation
const moonOrbit = new THREE.Object3D();
moonOrbit.add(tiltedMoon);

// Create an elliptical curve for the Moon's orbit in its orbital plane
const [points, rAsc, rDes] = ellipticCurve(MOON_DATA.A, MOON_DATA.EC, MOON_DATA.W);
const vertexBuffer = new THREE.BufferAttribute(points, 3);
const orbitGeometry = new THREE.BufferGeometry().setAttribute('position', vertexBuffer);
const orbitMaterial = new THREE.LineBasicMaterial({
  color: 0x4488ff, // light blue
  transparent: true,
  opacity: 0.35
});
const orbitPath = new THREE.LineLoop(orbitGeometry, orbitMaterial);
moonOrbit.add(orbitPath);

// Add parent to follow the Moon's orbit nodal precession (swivel)
const ascendingNodePivot = new THREE.Object3D();
ascendingNodePivot.add(moonOrbit);

// Add Moon hierarchy to the scene
scene.add(ascendingNodePivot);

// ============================================================================
// INITIAL POSITIONS SETUP
// ============================================================================

// Earth Prime Meridian at master epoch time
//
// Earth Texture map is loaded already centered on 0° longitude, i.e. the Prime
// Meridian intercept the +X axis on the equator in our earth object local reference.
// We convert the Greenwich Apparent Sidereal Time (GAST) at master epoch into
// a positive rotation along +Y axis (North Pole)
const InitialEarthY = EARTH_DATA.L_Ap_Sid_Time;

// Earth's obliquity (axial tilt) at Vernal Equinox
//
// The Earth's tilt axis at equinox time is perpendicular to the world X axis.
// So to tilt the axis we rotate around x-axis. The tilt must be directed towards
// the Winter Solstice (so that at Summer Solstice the North Pole will be tilted
// toward the sun), the positive +X axis points toward the Sun and the rotation
// is clockwise (negative).
const InitialTiltedEarthX = -toRadians(EARTH_AXIAL_TILT);

// Moon rotation
//
// Moon is in tidal locking, meaning it rotates on its axis at the same rate it orbits
// around Earth, which causes the same side to always face us.
// Moon Texture map is loaded centered on 0° longitude, the Prime Meridian of the Moon
// is aligned with its local +X axis.
// Moon's world frame is Earth centered and its +X axis is the direction from Earth to the
// Ascending Node.
// When the Moon is at the Ascending Node the 0° longitude will be on the far side
// of the Moon, so we need to rotate around +Y axis of 180 degree to move it facing Earth.
// Because of tidal locking, after initial offset the animation will always keep it facing Earth.
const InitialMoonY = Math.PI;

// Moon's obliquity (axial tilt)
//
// Cassini's 3rd Law dictates that the Moon's spin axis, its orbital pole,
// and the Ecliptic Pole are always coplanar. This has a practical consequence:
// the Moon's axial tilt is applied in the same plane as its orbital inclination.
//
// 1. The Moon's orbit is inclined by rotating the `moonOrbit` object around its
//    local X-axis (the line of nodes).
//
// 2. Therefore, the Moon's axial tilt must ALSO be a rotation around the local
//    X-axis of its parent frame (`moonOrbit`).
//
// Cassini's 3rd Law states also that pole of ecliptic (~1.54°) is always *between*
// the 2 poles of orbit (~5.1°) and spin (~6.68°), so the Moon's spin axis is "tilted
// back" from its orbital plane. This means the axial tilt rotation is in the OPPOSITE
// direction to the orbital inclination rotation.
// We apply this by rotating the tiltedMoon node around its local X-axis, which is
// the same axis as its parent's rotation but with an opposite sign.
const InitialTiltedMoonX = -toRadians(MOON_AXIAL_TILT);

// Moon's orbit inclination to Ecliptic
//
// The Ascending Node is the point where Moon's orbit crosses the Ecliptic plane.
// After passing the Ascending Node, the Moon "ascends" into the Northern
// Ecliptic hemisphere (i.e., its world Y-coordinate becomes positive).
// The local +X axis of this `moonOrbit` points to the Ascending Node.
// The Moon's orbit is positive counter-clockwise (prograde) and at ascending node
// it moves toward -Z.
// A positive (counter-clockwise) rotation around the local +X axis will rotate
// the local -Z axis towards the world +Y axis. This correctly lifts the subsequent
// part of the orbit into the positive ("North") direction, achieving the "ascending"
// motion.
const InitialMoonOrbitX = MOON_DATA.IN;

// Moon's orbital plane orientation (Longitude of the Ascending Node)
//
// The line of nodes for the Moon's orbit precesses in a retrograde (backward)
// direction, which is the opposite to the Moon's forward motion around the Earth.
// The longitude of the Ascending Node (OM) from JPL specifies the orientation
// of the Moon's orbital plane within the fixed Geocentric J2000 Ecliptic frame.
//
// This angle is measured eastward (counter-clockwise) from the frame's principal
// direction (the Vernal Equinox, our World +X axis) to the Ascending Node.
//
// To apply this, we rotate the `ascendingNodePivot` object around the World +Y
// axis (the Ecliptic North Pole) by the value of OM. No further correction
// for the Earth's position in its orbit is needed, as OM is already an
// absolute angle in this fixed reference frame.
const InitialAscendingNodePivotY = MOON_DATA.OM;

// **********************************************************************

// List of objects that can have a locked view on them
const trackableBodies = [earth, moon];

// Tracks state for an observer on a planet
const observerState = {
    object: null,
    marker:null, // in local coordinates
    observerOnEarth: false,
    moonVisible: false,
    viewIndex: null,
    tempVec: new THREE.Vector3(),
};

// Helper for debugging: Add axes helpers to visualize local frames
function addAxesHelper(object, size) {
    const axesHelper = new THREE.AxesHelper(size);
    object.add(axesHelper);
    return axesHelper;
}

// Helper used by observer and orbit locking
function createMarker(radius, color) {
  return new THREE.Mesh(
    new THREE.SphereGeometry(radius),
    new THREE.MeshBasicMaterial({ color })
  );
}

// Release marker resources
function disposeMarker(marker) {
  marker.geometry.dispose();
  marker.material.dispose();
}

// Add a child object, usually a marker, on a surface of
// a body and align local coordinates of added child
function attachToSurface(marker, object, surfacePoint) {

  // Surface point must be in world coords
  marker.position.copy(surfacePoint);
  object.worldToLocal(marker.position);
  orientToSurface(marker);
  if (marker.parent !== object) // in case we just move the marker
    object.add(marker);
  marker.updateWorldMatrix(true, false);
}

// Orient the local coordinate frame of an object on the surface of a parent body
function orientToSurface(marker) {

    // Point on the surface must be in parent coordinates
    const p = marker.position;

    // Calculate Local Y-axis (outward normal from sphere)
    const y_local = p.clone().normalize();

    // Calculate Local X-axis as tangential velocity (z, 0, -x) for Y-axis rotation
    const v = new THREE.Vector3(p.z, 0, -p.x);

    // Detect special case of point exactly on the global Y-axis (pole) and
    // fallback on parent X-axis
    const onY = v.lengthSq() === 0;
    const x_local = onY ? new THREE.Vector3(1, 0, 0) : v.normalize();

    // Local Z-axis is cross product of x_local and y_local for right-handed system
    const z_local = new THREE.Vector3().crossVectors(x_local, y_local);

    // Rotation matrix whose columns are the local basis vectors (x_local, y_local, z_local)
    // This matrix transforms from point's local frame to its parent's (sphere's) frame.
    const rotationMatrix = new THREE.Matrix4();
    rotationMatrix.makeBasis(x_local, y_local, z_local);

    // Set point's quaternion from this rotation matrix
    marker.quaternion.setFromRotationMatrix(rotationMatrix);
}

// Return any trackable object under mouse
function pickObject(mouseX, mouseY) {

  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  // Convert mouse position to normalized device coordinates (-1 to +1)
  mouse.x =  (mouseX / window.innerWidth)  * 2 - 1;
  mouse.y = -(mouseY / window.innerHeight) * 2 + 1;

  // Update the raycaster with the camera and mouse position
  const view = views.getActive();
  raycaster.setFromCamera(mouse, view.camera);

  // Find intersections with candidates
  const intersects = raycaster.intersectObjects(trackableBodies);
  if (intersects.length === 0)
    return null;

  return {
    object: intersects[0].object,
    point: intersects[0].point // point on the surface in world space
  };
}

// Lock the camera into a geostationary orbit around the selected object
function lockToOrbit(objectToLock, surfacePoint) {

  // Set a marker in local coordinates on object's surface point
  const marker = createMarker(toUnits(50), 0x00ff00);
  attachToSurface(marker, objectToLock, surfacePoint);

  // Lock the active view aligned to object's center
  views.lockToOrbitView(marker, objectToLock);
}

// Place an observer on an object surface
function enterObserverMode(object, surfacePoint) {

  // Currently we handle only one observer
  console.assert(observerState.object === null, "Setting already existing observer");

  // Position and orient the marker on the surface
  const marker = createMarker(toUnits(10), 0xFFFFFF);
  attachToSurface(marker, object, surfacePoint);

  observerState.object = object;
  observerState.marker = marker;

  // Init observer events
  observerState.observerOnEarth = (object === earth);
  observerState.moonVisible = isAboveHorizon(tiltedMoon, toUnits(MOON_RADIUS_KM));

  // Create a new observer view placed on marker
  const eyeHeight = toUnits(5); // km above surface
  const lookAhead = toUnits(100); // look at km ahead on horizon
  const viewIndex = views.createObserverView(marker, eyeHeight, lookAhead);
  observerState.viewIndex = viewIndex;

  // Lock the view camera on the marker
  const view = views.get(viewIndex);
  view.lockTo(marker, true);

  return viewIndex;
}

// Move the marker to a new position on planet surface
function placeObserverAt(latDeg, lonDeg) {

  const view = views.get(observerState.viewIndex);
  if (views.getActive() !== view)
    return;

  const latRad = toRadians(latDeg);
  const lonRad = toRadians(lonDeg);
  const radius = observerState.marker.position.length();

  // Convert spherical coordinates to Cartesian (x, y, z) in the planet's local
  // frame. Y is the polar axis. +X is the prime meridian (0° longitude).
  // The -z for sine is to match the longitude calculation in getGeoData.
  const newSurfacePoint = new THREE.Vector3();
  newSurfacePoint.y = radius * Math.sin(latRad);
  const xzRadius = radius * Math.cos(latRad); // Radius of the circle at this latitude
  newSurfacePoint.x = xzRadius * Math.cos(lonRad);
  newSurfacePoint.z = -xzRadius * Math.sin(lonRad);

  // Move the marker to new surface point and realign its plane
  // Surface point must be in world coords
  const object = observerState.object;
  object.localToWorld(newSurfacePoint)
  attachToSurface(observerState.marker, object, newSurfacePoint);

  // Camera is already locked to the marker, locking update will
  // set correct camera and target position at next frame.
}

// Drop observer view and release relative resources
function exitObserverMode() {
  const view = views.get(observerState.viewIndex);
  view.unlock();
  const marker = observerState.marker;
  marker.parent.remove(marker);
  disposeMarker(marker);
  views.dispose(observerState.viewIndex);
  observerState.object = null;
  observerState.viewIndex = null;
  observerState.marker = null;
}

// ============================================================================
// CELESTIAL BODY CREATION
// ============================================================================

/*
  Setup a hierarchy of 3D Objects to apply rotations in an independent order
  withouth the limitation of the fixed XYZ order by default Three.js
*/

// Computes an array of 3D vertex on an elliptic curve in the Moon's orbital plane.
// The Earth is at the origin (0,0,0). The function's output coordinate system is
// designed to match the local frame of the `moonOrbit` node it will be attached to.
//
// - The local +X axis represents the "line of nodes," pointing to the Ascending Node.
// - The local XZ plane represents the Moon's orbital plane.
// - In the `moonOrbit`'s right-handed local frame (where +X=Ascending Node and
//   +Y=North Ecliptic Pole), prograde (counter-clockwise) motion from the
//   Ascending Node proceeds into the NEGATIVE Z direction.
//
// To model this physical reality, the z-coordinate is calculated as -r * sin(angle).
function ellipticCurve(A, EC, W) {
  const SEGMENTS = 360;
  const points = new Float32Array(SEGMENTS * 3);

  // Distance from Earth given true anomaly ta (ellipse polar equation)
  const distance = ta => A * (1 - EC * EC) / (1 + EC * Math.cos(ta));

  // Loop starts at perigee (W) when i = 0, and angle 0 (ta = -W)
  // corresponds to the ascending node.
  for (let i = 0; i < SEGMENTS; i++) {
    const ta = (i / SEGMENTS) * 2 * Math.PI; // true anomaly
    const r = distance(ta); // distance from Earth at true anomaly
    const angle = ta + W; // angle from ascending node
    points[i*3 + 0] = r * Math.cos(angle); // x
    points[i*3 + 1] = 0;                   // y  (on orbital plane)
    points[i*3 + 2] = -r * Math.sin(angle); // -z due to parent local frame
  }

  // Find ascending and descending nodes x-axis coordinates
  const rAsc = distance(-W);
  const rDes = distance(-W + Math.PI);
  return [points, rAsc, rDes];
}

// Setup the node markers corresponding to ascending/descending nodes
function getMarker(color, position) {
  const geometry = new THREE.SphereGeometry(toUnits(600));
  const material = new THREE.MeshBasicMaterial({ color: color });
  const marker = new THREE.Mesh(geometry, material);
  marker.position.set(...position);
  return marker;
}
// Nodes lay on x-axis in local coordinates
moonOrbit.add(getMarker(0xff00ff, [+rAsc, 0, 0])); // Magenta
moonOrbit.add(getMarker(0xffff00, [-rDes, 0, 0])); // Yellow

// ============================================================================
// CELESTIAL BODY RUNTIME COMPUTATIONS
// ============================================================================


// Solves Kepler's Equation for Eccentric Anomaly (E) with
// the Newton-Raphson iterative method
function solveKepler(M, e) {

  // Kepler's Equation is: M = E - e * sin(E)
  const maxIterations = 10;
  const tolerance = 1e-6; // A small tolerance for accuracy
  let E = M; // Initial guess for E is M

  for (let i = 0; i < maxIterations; i++) {
    const f = E - e * Math.sin(E) - M; // The function we want to find the root of
    const fPrime = 1 - e * Math.cos(E); // The derivative df/dE
    const deltaE = f / fPrime;

    E = E - deltaE; // New, better guess for E

    if (Math.abs(deltaE) < tolerance)
      break; // Solution is accurate enough
  }
  return E;
}

// Return orbital parameters from ellipse's focus PV
function solveOrbit(elapsedTime, bodyData) {

  // Solve Kepler's equation to get Eccentric Anomaly (E), angle from
  // ellipse center if orbit was a circle, out of Eccentricity (EC) and
  // current Mean Anomaly (M), angle from periapsis if orbit was a circle
  const n = 2 * Math.PI / bodyData.PR; // Mean motion (rad/sec)
  const M = bodyData.MA + n * elapsedTime; // Mean Anomaly
  const EC = bodyData.EC; // Eccentricity
  const E = solveKepler(M, EC); // Eccentric anomaly

  // Calculate the True Anomaly (TA or ν), and the angle from
  // perige (viewed from the nearest focus)
  const [sinE, cosE] = [Math.sin(E), Math.cos(E)];
  const cosTA = (cosE - EC) / (1 - EC * cosE);
  const sinTA = Math.sqrt(1 - EC * EC) * sinE / (1 - EC * cosE);
  const TA = Math.atan2(sinTA, cosTA);

  // Calculate distance from focus
  const r = bodyData.A * (1 - EC * EC) / (1 + EC * Math.cos(TA));

  return [TA, r];
}

// Calculate the Moon's position vector in Geocentric Moon Orbital frame
function getMoonPosition(elapsedTime) {

  // Get True Anomaly and Moon-Earth distance in geocentric reference (from focus POV)
  const [TA, r] = solveOrbit(elapsedTime, MOON_DATA);

  // Calculate position in the Moon's tilted orbital plane
  const angleFromAscendingNode = TA + MOON_DATA.W; // x-axis is at ascending node
  const x_moon =  r * Math.cos(angleFromAscendingNode);
  const z_moon = -r * Math.sin(angleFromAscendingNode); // -z due to local frame

  // The position is set in the local frame of the 'moonOrbit' object, whose
  // XZ plane represents the 2D tilted orbital plane.
  return [x_moon, 0, z_moon];
}

// Calculate the Sun's position vector in Geocentric World frame
function getSunPosition(elapsedTime) {

  // Get True Anomaly and Sun-Earth distance in heliocentric J2000 reference
  const [TA, r] = solveOrbit(elapsedTime, EARTH_DATA);

  // True Longitude is the angle of Earth measured counter-clockwise in the
  // Ecliptic plane, starting from the Vernal Equinox at J2000 Epoch
  const LP = EARTH_DATA.OM + EARTH_DATA.W;
  const trueLongitude = TA + LP;
  const x_earth = r * Math.cos(trueLongitude);
  const y_earth = r * Math.sin(trueLongitude);

  // The Sun's position (-x,-y) from the Earth is the negate of the
  // Earth's position (x, y) from the Sun, but +X axis in Heliocentric
  // J2000 is -X in Geocentric World:
  //      J2000 (x_earth, y_earth, 0) -> World (x_earth, 0, -y_earth)
  return [-x_earth, 0, y_earth]; // FIXME it should be [x_earth, 0, -y_earth]
}

function isAboveHorizon(target, radius) {

  // Get target's position in the observer frame
  const temp = observerState.tempVec;
  target.getWorldPosition(temp);
  const targetLocalPos = observerState.marker.worldToLocal(temp);

  // Correction for the object's upper limb (its radius)
  const radiusCorrection = radius;

  // Correction for atmospheric refraction (lifts the image)
  let refractionCorrection = 0;
  if (observerState.observerOnEarth) {
    const distance = targetLocalPos.length();
    refractionCorrection = distance * Math.tan(HORIZON_REFRACTION);
  }

  // The object is visible if its center is above this negative threshold
  const visibilityThreshold = -(radiusCorrection + refractionCorrection);
  return targetLocalPos.y > visibilityThreshold;
}

// ============================================================================
// ANIMATION LOOP
// ============================================================================

// Calculate simulation constants and state
const earthRotationSpeed = 2 * Math.PI / SIDERAL_DAY;
const moonSiderealRotationSpeed = 2 * Math.PI / MOON_DATA.PR;
const precessionSpeed = 2 * Math.PI / EARTH_PRECESSION_PERIOD;
const moonNodeSpeed = 2 * Math.PI / MOON_NODE_PRECESSION_PERIOD;

// Clock works also when tab is hidden, can be set/reset by UI, time
// can run faster and/or backward from real time and is adjustable
const SimClock = class {
  constructor(masterEpoch) {
    this.masterEpochTime = masterEpoch.getTime(); // our t=0
    this.reset();
    this.running = true;
  }
  reset() {
    this.simulationTimeAtPause = Date.now();
    this.realTimeAtResume = this.simulationTimeAtPause;
    this.speedX = SIM_TIME_SPEED_UP;
  }
  setDate(newDate) {
    // Adjust the "banked" time to make the total time equal the newDate
    this.simulationTimeAtPause = newDate.getTime() - this._deltaSinceLastResume();
  }
  _deltaSinceLastResume() {
    // Accumulate time only while running. It is simulation time, not real time
    return this.running ? this.speedX * (Date.now() - this.realTimeAtResume) : 0;
  }
  getTime() {
    const simTime = this.simulationTimeAtPause + this._deltaSinceLastResume();
    return simTime; // in msecs
  }
  elapsed() {
    // Initial offsets in simulation are computed on master epoch
    return this.getTime() - this.masterEpochTime;
  }
  togglePause() {
    if (this.running) {
      // Before stopping, add the "ticking" time to the "banked" time
      this.simulationTimeAtPause += this._deltaSinceLastResume();
    } else {
      this.realTimeAtResume = Date.now();
    }
    this.running = !this.running;
    return this.running;
  }
  speed() {
    return this.speedX / SIM_TIME_SPEED_UP; // SIM_TIME_SPEED_UP -> speed == 1
  }
  setSpeed(speed) {
    // Bank any accumulated time at the old speed by simulating a
    // stop/start, then set the new speed. It works whether the
    // clock is running or paused.
    this.togglePause();
    this.togglePause();
    this.speedX = SIM_TIME_SPEED_UP * speed;
  }
};
const simClock = new SimClock(MASTER_EPOCH);

const transientEvents = { atRise: false, atSet: false, azEl: [], latLon: [] };

// Rescaled Sun distance for placing directional Sun light source
const SUN_LIGHT_DISTANCE = toUnits(10 * MOON_DISTANCE_KM);

const sunPositionVec = new THREE.Vector3();

// Animation loop function
function animate() {

  const elpasedMsec = simClock.elapsed(); // in msecs
  const elapsed = elpasedMsec / 1000; // in secs

  // Orbit Sun around Earth, we use a rescaled distance for rendering purposes
  const [xs, ys, zs] = getSunPosition(elapsed);
  sunPositionVec.set(xs, ys, zs).normalize().multiplyScalar(SUN_LIGHT_DISTANCE);
  sunLight.position.copy(sunPositionVec);

  // Rotate Earth
  earth.rotation.y = InitialEarthY + earthRotationSpeed * elapsed;

  // Earth axial precession
  // First tilt around x, then rotate y. Three.js rotation order is 'XYZ'
  tiltedEarth.rotation.x = InitialTiltedEarthX;
  tiltedEarth.rotation.y = -precessionSpeed * elapsed; // clockwise (negative)

  // Moon rotation around its Pole axis, in tidal locking with Earth
  moon.rotation.y = InitialMoonY + moonSiderealRotationSpeed * elapsed;

  // Moon's axis precession??? FIXME
  tiltedMoon.rotation.x = InitialTiltedMoonX;

  // Moon orbit around Earth (relative to the orbital plane)
  const [xm, ym, zm] = getMoonPosition(elapsed);
  tiltedMoon.position.set(xm, ym, zm); // FIXME is clockwise

  // Moon's orbit plane. Precession here??? FIXME
  moonOrbit.rotation.x = InitialMoonOrbitX;

  // The Moon's ascending node precesses backwards (retrograde).
  // This is a rotation around the Ecliptic Pole (the Y-axis).
  ascendingNodePivot.rotation.y = InitialAscendingNodePivotY - moonNodeSpeed * elapsed;

  if (observerState.object) {
    // Pause animation at Moon raise/set. Handle simulation in reverse time
    const isMoonVisible = isAboveHorizon(tiltedMoon, toUnits(MOON_RADIUS_KM));
    const timeForward = (simClock.speed() > 0);
    const visibilityChanged = (isMoonVisible != observerState.moonVisible);
    const atRaise = visibilityChanged && (isMoonVisible === timeForward);
    const atSet   = visibilityChanged && !atRaise;
    observerState.moonVisible = isMoonVisible;

    // If we are in observer view pass elevation and azimuth
    const view = views.get(observerState.viewIndex);
    const isAct = (view == views.getActive());
    const { azEl, latLon } = isAct ? view.getGeoData(observerState.marker) : { azEl: [], latLon: []};
    Object.assign(transientEvents, { atRise: atRaise, atSet: atSet, azEl: azEl, latLon: latLon });
  }

  // Update the active controls and render with the active camera
  const activeCamera = views.update();
  renderer.render(scene, activeCamera);
  return transientEvents;
}

// ============================================================================
// EXPORT CLASS
// ============================================================================

class Simulation {
  constructor() {
    this.update = animate;
    this.getTime = simClock.getTime.bind(simClock);
    this.setDate = simClock.setDate.bind(simClock);
    this.speed = simClock.speed.bind(simClock);
    this.setSpeed = simClock.setSpeed.bind(simClock);
    this.togglePause = simClock.togglePause.bind(simClock);
    this.setActiveView = views.setActive.bind(views);
    this.disposeView = views.dispose.bind(views);
    this.lockToOrbit = lockToOrbit;
    this.enterObserverMode = enterObserverMode;
    this.placeObserverAt = placeObserverAt;
    this.exitObserverMode = exitObserverMode;
    this.pickObject = pickObject;
  }
  getRenderer() {
    return renderer;
  }
  reverseSpeed() {
    const speed = -simClock.speed();
    simClock.setSpeed(speed);
    return speed;
  }
  reset() {
    simClock.reset();
    views.setDefault();
  }
  isObserverView() {
    return views.getActive() === views.get(observerState.viewIndex);
  }
  isOrbitLocked(object) {
    const lockedObjects = views.getOrbitLockedObjects();
    return lockedObjects.includes(object);
  }
  unlockCamera() {
    const view = views.getActive();
    const marker = view.cameraLock.target;
    marker.parent.remove(marker);
    disposeMarker(marker);
    view.unlock();
  }
  cloneView() {
    const v = views.getActive();
    const newViewIndex = views.clone(v);
    return newViewIndex;
  }
  resize() {
    const v = views.getActive();
    const camera = v.camera;
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    views.renderer.setSize(innerWidth, innerHeight);
  }
};

export default Simulation;
