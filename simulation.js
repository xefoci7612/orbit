'use strict';

/*
  TODO:
    - When locked reset return to "at lock time" position
    - Show sun/raise events with a fading side legend
*/


/*
  Our World Frame is a right-handed coordinate system derived from ICRS Heliocentric
  Ecliptic J2000 Frame and adapted to Three.js conventions for axes

  ICRS Heliocentric Ecliptic J2000 Frame

    J2000 Frame uses a standard heliocentric, right-handed coordinate system to
    model the Solar System's geometry.

    EPOCH (J2000.0):
        The reference frame is fixed to a specific moment: January 1, 2000, at 12:00
        Terrestrial Time (TT), which is Julian Date 2451545.0 TT.

    ORIGIN:
        The formal origin (0,0,0) is the Barycenter of the Solar System

    THE FUNDAMENTAL PLANE (THE XY PLANE):
        This is the Earth's mean orbital plane as it existed at the J2000.0 epoch,
        also known as the "Ecliptic of J2000.0"

    AXES DEFINITION:
      +X Axis: Points from the Sun towards the Vernal Equinox as it was at the J2000.0
               epoch. This is the principal direction of the reference frame.

      +Z Axis: Points towards the North Ecliptic Pole at the J2000.0 epoch. It is
               perpendicular to the XY plane

      +Y Axis: Completes the right-handed coordinate system (X × Y = Z). This axis
               points towards the Summer Solstice direction. At the Vernal Equinox,
               the +Y axis has same direction as Earth's velocity.


  Scene World Coordinates Frame

   We use a right-handed heliocentric coordinate system (referred as World Coordinates)
   adapted to Three.js conventions for axes.

    Differences from ICRS Heliocentric Ecliptic J2000 Frame:

      +Y Axis: Is the +Z Axis in J2000 Frame (UP direction)

      +Z Axis: Is the -Y Axis in the Ecliptic J2000 Frame
*/

import * as THREE from 'three';
import { ViewManager } from './view.js';
import { init_debug, set_sunline_length } from './validate.js';

export const DEBUG = false; // Enable axes and objects visualizations for debug purposes
export const VALIDATE = false; // Run validation script instead of normal visualization mode

const EARTH_TEXTURE_URL = 'textures/earth_atmos_2048.jpg';
const MOON_TEXTURE_URL = 'textures/moon_1024.jpg';
const SKY_TEXTURE_URL = [  // In celestial coordinates from https://svs.gsfc.nasa.gov/4851
    'textures/sky_px.png', // Right
    'textures/sky_nx.png', // Left
    'textures/sky_py.png', // Top
    'textures/sky_ny.png', // Bottom
    'textures/sky_pz.png', // Front
    'textures/sky_nz.png'  // Back
];

// Physical properties (in kilometers, converted to scene units)
const EARTH_RADIUS_KM = 6371; // Conventional radius for sphere approx.
const MOON_RADIUS_KM = 1737.53;
const SUN_RADIUS_KM = 695700;
const MOON_DISTANCE_KM = 384400;    // average
const EARTH_AXIAL_TILT = 23.439291; // degrees
const MOON_AXIAL_TILT = 6.68;       // degrees

// Earth-Moon Barycenter (EBM) Correction Constants to convert
// the EMB->Moon distance to the EMB->Earth distance
//  m₁ × d₁ = m₂ × d₂  --> EBM_E = EBM_M * MOON_EARTH_MASS_RATIO
const MOON_EARTH_MASS_RATIO = 1 / 81.3;

// Scale conversions
const KM_PER_UNIT = EARTH_RADIUS_KM / 50; // Earth radius to units
const toUnits = km => km / KM_PER_UNIT;
const fromUnits = u => u * KM_PER_UNIT;
const toRadians = degrees => degrees * Math.PI / 180;
const HMSToRadians = s => s.split(/\s+/).reduce((acc, v, i) => acc + parseFloat(v) / [1, 60, 3600][i], 0) * (Math.PI / 12);

// Time constants for simulation
const SIM_TIME_SPEED_UP = 60; // 1 simulation hour elapses in 1 minute

// Master Epoch of JPL data sources
const MASTER_EPOCH = new Date('2025-09-10T09:34:03Z');
const J2000_EPOCH = new Date('2000-01-01T12:00:00Z');

const HOUR = 3600; // In SI seconds
const SOLAR_DAY = 24 * HOUR; // Mean Solar Day
const JULIAN_YEAR = 365.25 * SOLAR_DAY;

const SIDERAL_DAY = 23.9344696 * HOUR; // Period of a 360 degrees rotation
const SIDEREAL_YEAR = 365.256363004 * SOLAR_DAY; // For epoch J2000.0

const EARTH_PRECESSION_PERIOD = 25772 * JULIAN_YEAR;
const MOON_NODE_PRECESSION_PERIOD = 18.612815932 * JULIAN_YEAR;

// Standard atmospheric refraction in arcminutes
const HORIZON_REFRACTION = toRadians(34.5 / 60);

/*
    Moon and Earth Ephemeris (osculating elements) from JPL Horizons

    https://ssd.jpl.nasa.gov/horizons/app.html

    The raw values (IN, OM, W, etc.) are generated by JPL Horizons.

    The refrence frame is the ICRS Ecliptic at J2000 Epoch with origin
    at EBM and at Sun respectively for Moon and EBM (Earth) data

    Simulation uses the JPL Ephemeris to solve an elliptical 2D orbit
    defined as follow:

    EPOCH: JPL osculating elements refer to MASTER_EPOCH time

    ORIGIN: The origin (0,0) is the nearest focus of the orbital ellipses

    THE ORBITAL PLANE: The local XZ plane

    AXES DEFINITION:
      +X Axis: This is the principal direction, defined as the "line of nodes".
               It points from the focus towards the Ascending Node

      +Y Axis: Perpendicular to the orbital plane, pointing towards the orbital
               north pole. At the Ascending Node the orbit moves from -Y to +Y

      +Z Axis: Completes the right-handed system. At the Ascending Node
               a counter-clockwise orbit moves toward -Z axis
*/

// Target Body: Earth-Moon Barycenter [EMB], Coordinate Center: Solar System Barycenter (SSB) [code: 500@0]
const EMB_DATA = {
     A: toUnits(1.486460015779342E+08),
    EC: 2.348399511484001E-02,
    IN: toRadians(9.565607274919776E-03),
    OM: toRadians(2.345912713353362E+02),
     W: toRadians(2.311018377459241E+02),
    MA: toRadians(2.439258621986873E+02),
    PR: 3.123666754246648E+07,
};

// Target Body: Moon [Luna], Coordinate Center: Earth-Moon Barycenter [500@3]
const MOON_DATA = {
     A: toUnits(3.796241532734630E+05),
    EC: 5.078618152688460E-02,
    IN: toRadians(5.280291370607761E+00),
    OM: toRadians(3.479716750341908E+02),
     W: toRadians(3.711163694612181E+01),
    MA: toRadians(1.290172290680006E+01),
    PR: 2.343381844716793E+06,
};

// Target Body: Earth, Coordinate Center: Earth-Moon Barycenter [500@3]
const EARTH_DATA = {
     A: toUnits(4.669391144219639E+03),
    EC: 5.078618152693617E-02,
    IN: toRadians(5.280291370607768E+00),
    OM: toRadians(3.479716750341909E+02),
     W: toRadians(2.171116369461202E+02),
    MA: toRadians(1.290172290678550E+01),
    PR: 2.343381844717038E+06,

    L_Ap_Sid_Time: HMSToRadians("08 52 45.4526"), // Greenwich Apparent Sidereal Time (GAST)
};

// Calculate simulation constants and state
const earthRotationSpeed = 2 * Math.PI / SIDERAL_DAY;
const moonSiderealRotationSpeed = 2 * Math.PI / MOON_DATA.PR;
const earthPrecessionSpeed = 2 * Math.PI / EARTH_PRECESSION_PERIOD;
const moonNodeSpeed = 2 * Math.PI / MOON_NODE_PRECESSION_PERIOD;

// ============================================================================
// SCENE SETUP
// ============================================================================

/*
  Setup a hierarchy of 3D Objects to split complex movement in independent
  rotations
*/

// Helper to create a marker object
function getMarker(color, position) {
  const geometry = new THREE.SphereGeometry(toUnits(600));
  const material = new THREE.MeshBasicMaterial({ color: color });
  const marker = new THREE.Mesh(geometry, material);
  marker.position.set(...position);
  return marker;
}

// Create renderer and scene
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight); // Full viewport
document.body.appendChild(renderer.domElement);
const cubeTextureLoader = new THREE.CubeTextureLoader();
const scene = new THREE.Scene();
scene.background = cubeTextureLoader.load(SKY_TEXTURE_URL);

// Ambient light for overall scene illumination
const ambientLight = new THREE.AmbientLight(0xffffff, 0.05); // White light, low intensity
scene.add(ambientLight);

// Directional light for sun light, set at the Origin
const sunLight = new THREE.DirectionalLight(0xffffff, 1);
sunLight.position.set(0, 0, 0); // default is 'looking from top'
scene.add(sunLight);
scene.add(sunLight.target); // target must be added too!


// Sun hierarchy
//
// The Sun-EMB 2D orbital plane, Sun is at the focus/origin
// of the local coordinate frame
const sunOrbitalPlane = new THREE.Object3D();
scene.add(sunOrbitalPlane);

// EMB (Earth-Moon Barycenter) orbits around the Sun
const embPivot = new THREE.Object3D();
sunOrbitalPlane.add(embPivot);


// Moon hierarchy
//
// The EMB-Moon 2D orbital plane, EMB is at the focus/origin of
// local coordinate frame
const moonOrbitalPlane = new THREE.Object3D();
embPivot.add(moonOrbitalPlane);

// Moon with tilted vertical axis, it is the object that orbits
// around EMB
const tiltedMoon = new THREE.Object3D();
moonOrbitalPlane.add(tiltedMoon);

// The actual Moon Mesh object, in tidal locked rotation
// around its pole axis
const textureLoader = new THREE.TextureLoader();
const moonTexture = textureLoader.load(MOON_TEXTURE_URL);
const moon = new THREE.Mesh(
  new THREE.SphereGeometry(toUnits(MOON_RADIUS_KM), 32, 32),
  new THREE.MeshStandardMaterial({ map: moonTexture, roughness: 0.9 })
);
tiltedMoon.add(moon);


// Earth hierarchy
//
// Earth with tilted vertical axis, it is the object that orbits
// around EMB point. Physically it lays on the Moon orbital plane
const tiltedEarth = new THREE.Object3D();
moonOrbitalPlane.add(tiltedEarth);

// The actual Earth Mesh object, performs daily rotation
// around its pole axis
const earthTexture = textureLoader.load(EARTH_TEXTURE_URL);
const earth = new THREE.Mesh(
  new THREE.SphereGeometry(toUnits(EARTH_RADIUS_KM), 64, 64),
  new THREE.MeshStandardMaterial({ map: earthTexture, roughness: 0.8 })
);
tiltedEarth.add(earth);

// An elliptical curve to show Moon's orbit
const [points, rMoonAsc, rMoonDes] = ellipticCurve(MOON_DATA.A, MOON_DATA.EC, MOON_DATA.W);
const vertexBuffer = new THREE.BufferAttribute(points, 3);
const orbitPathGeo = new THREE.BufferGeometry().setAttribute('position', vertexBuffer);
const orbitPathMat = new THREE.LineBasicMaterial({
  color: 0x4488ff, // light blue
  transparent: true,
  opacity: 0.35
});
const moonOrbitPath = new THREE.LineLoop(orbitPathGeo, orbitPathMat);
moonOrbitalPlane.add(moonOrbitPath);

// Add markers on the Moon's orbit ascending and descending nodes
moonOrbitalPlane.add(getMarker(0xff00ff, [+rMoonAsc, 0, 0])); // Magenta
moonOrbitalPlane.add(getMarker(0xffff00, [-rMoonDes, 0, 0])); // Yellow

// Add additional elements if debug is enabled
if (DEBUG)
    init_debug(scene, tiltedEarth, earth);

// Initial/default camera view
const defaultCameraPos = (function() {
  const cameraDistance = toUnits(2 * MOON_DISTANCE_KM); // From Earth center
  const cameraAzimuth = toRadians(180);  // Degrees clockwise from +Z axis
  const cameraElevation = toRadians(10); // Degrees above horizontal plane
  return new THREE.Vector3(
    cameraDistance * Math.cos(cameraElevation) * Math.sin(cameraAzimuth),
    cameraDistance * Math.sin(cameraElevation),
    cameraDistance * Math.cos(cameraElevation) * Math.cos(cameraAzimuth)
  );
})();
// Here we only instantiate the view maanger, we must init the main view later
// when we know Earth position
const views = new ViewManager(scene, renderer, defaultCameraPos);


// ============================================================================
// INITIAL POSITIONS SETUP
// ============================================================================

// Earth Prime Meridian at master epoch time
//
// Earth Texture map is loaded already centered on 0° longitude, i.e. the Prime
// Meridian intercept the +X axis on the equator in our earth object local reference.
// We convert the Greenwich Apparent Sidereal Time (GAST) at master epoch into
// a positive rotation along +Y axis (North Pole). We also add a 180 degree offset
// to account for world X-axis to be in opposite direction (from Sun toward Earth)
const InitialEarthY = EARTH_DATA.L_Ap_Sid_Time + Math.PI;

// Earth's obliquity (axial tilt) at Vernal Equinox
//
// The Earth's tilt axis at equinox time is perpendicular to the world X axis.
// So to tilt the axis we rotate around x-axis. The tilt must be directed towards
// the Winter Solstice (so that at Summer Solstice the North Pole will be tilted
// toward the sun), because the positive +X axis points from Sun toward Earth
// the rotation is counter-clockwise (positive).
const InitialTiltedEarthX = toRadians(EARTH_AXIAL_TILT);

// Calculate the initial precesssion, the rotation of Y-axis since J2000 Epoch
// The rotation is retrograde (clockwise), hence the negative sign
const timeSinceJ2000 = (MASTER_EPOCH.getTime() - J2000_EPOCH.getTime()) / 1000; // in secs
const InitialPrecessionY = -earthPrecessionSpeed * timeSinceJ2000;

// Earth's Orbit Inclination to Ecliptic
//
// The local +X axis of the orbital plane points towards the Ascending Node,
// the point where Earth's orbit crosses the J2000 Ecliptic plane while moving
// into the northern hemisphere.
// Earth's orbit is prograde (counter-clockwise). A positive rotation around the
// local +X axis correctly lifts the subsequent part of the orbit into the positive
// ("North") Y direction, achieving the "ascending" motion.
const InitialEarthOrbitX = EMB_DATA.IN;

// Earth's Orbital Plane Orientation (Longitude of the Ascending Node)
//
// The longitude of the Ascending Node (OM) specifies the orientation
// of Earth's orbital plane within the fixed J2000 Ecliptic frame.
// The OM angle is measured counter-clockwise from the Vernal Equinox
// (the frame's +X axis) to the Ascending Node.
//
// The precession of this angle is extremely slow (apsidal precession,
// ~112,000 years) and is treated as static in this simulation.
const InitialEarthOrbitY = EMB_DATA.OM;

// Moon rotation
//
// Moon Texture map is loaded centered on 0° longitude, the Prime Meridian of
// the Moon is aligned with its local +X axis.
// Moon's world frame is it's orbital plane and its +X axis is the direction
// from the EMB focus to the Ascending Node, so when the Moon is at the Ascending
// Node the 0° longitude will be on the far side of the Moon. We rotate around +Y
// axis of 180 degree to move it facing Earth.
const InitialMoonY = Math.PI;

// Moon's obliquity (axial tilt)
//
// Cassini's 3rd Law dictates that the Moon's spin axis, its orbital pole,
// and the Ecliptic Pole are always coplanar. This has a practical consequence:
// the Moon's axial tilt is applied in the same plane as its orbital inclination.
//
// 1. The Moon's orbit is inclined by rotating the orbital plane around its
//    local X-axis (the line of nodes).
//
// 2. Therefore, the Moon's axial tilt must also be a rotation around the local
//    X-axis of its parent orbital plane.
//
// Cassini's 3rd Law states also that pole of ecliptic (~1.54°) is always *between*
// the 2 poles of orbit (~5.1°) and spin (~6.68°), so the Moon's spin axis is "tilted
// back" from its orbital plane. This means the axial tilt rotation is in the opposite
// direction to the orbital inclination rotation.
// We apply this by rotating the tiltedMoon node around its local X-axis, which is
// the same axis as its parent's rotation but with an opposite sign.
const InitialTiltedMoonX = -toRadians(MOON_AXIAL_TILT);

// Moon's orbit inclination to Ecliptic
//
// The Moon's orbit is counter-clockwise (prograde) and at ascending node
// it moves toward -Z. A positive (counter-clockwise) rotation around the
// local +X axis correctly lifts the subsequent part of the orbit into the
// positive ("North") Y direction, achieving the "ascending" motion.
const InitialMoonOrbitX = MOON_DATA.IN;

// Moon's orbital plane orientation (Longitude of the Ascending Node)
//
// The longitude of the Ascending Node (OM) specifies the orientation
// of Moon's orbital plane within the local frame centered on EBM
// The OM angle is measured counter-clockwise from the the frame's +X axis
// to the Ascending Node.
//
// The line of nodes of the Moon's orbit precesses in a retrograde (backward)
// direction, which is the opposite to the Moon's counter-clockwise motion
// around Earth.
const InitialAscendingNodePivotY = MOON_DATA.OM;


// **********************************************************************

// List of objects that can have a locked view on them
const trackableBodies = [earth, moon];

// Tracks state for an observer on a planet
const observerState = {
    object: null,
    marker:null, // in local coordinates
    observerOnEarth: false,
    moonVisible: null,
    sunVisible: null,
    viewIndex: null,
    tempVec: new THREE.Vector3(),
};

// Helper used by observer and orbit locking
function createMarker(radius, color) {
  return new THREE.Mesh(
    new THREE.SphereGeometry(radius),
    new THREE.MeshBasicMaterial({ color })
  );
}

// Release marker resources
function disposeMarker(marker) {
  marker.geometry.dispose();
  marker.material.dispose();
}

// Add a child object, usually a marker, on a surface of
// a body and align local coordinates of added child
function attachToSurface(marker, object, surfacePoint) {

  // Surface point must be in world coords
  marker.position.copy(surfacePoint);
  object.worldToLocal(marker.position);
  orientToSurface(marker);
  if (marker.parent !== object) // in case we just move the marker
    object.add(marker);
  marker.updateWorldMatrix(true, false);
}

// Orient the local coordinate frame of an object on the surface of a parent body
function orientToSurface(marker) {

    // Point on the surface must be in parent coordinates
    const p = marker.position;

    // Calculate Local Y-axis (outward normal from sphere)
    const y_local = p.clone().normalize();

    // Calculate Local X-axis as tangential velocity (z, 0, -x) for Y-axis rotation
    const v = new THREE.Vector3(p.z, 0, -p.x);

    // Detect special case of point exactly on the global Y-axis (pole) and
    // fallback on parent X-axis
    const onY = v.lengthSq() === 0;
    const x_local = onY ? new THREE.Vector3(1, 0, 0) : v.normalize();

    // Local Z-axis is cross product of x_local and y_local for right-handed system
    const z_local = new THREE.Vector3().crossVectors(x_local, y_local);

    // Rotation matrix whose columns are the local basis vectors (x_local, y_local, z_local)
    // This matrix transforms from point's local frame to its parent's (sphere's) frame.
    const rotationMatrix = new THREE.Matrix4();
    rotationMatrix.makeBasis(x_local, y_local, z_local);

    // Set point's quaternion from this rotation matrix
    marker.quaternion.setFromRotationMatrix(rotationMatrix);
}

// Return any trackable object under mouse
function pickObject(mouseX, mouseY) {

  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  // Convert mouse position to normalized device coordinates (-1 to +1)
  mouse.x =  (mouseX / window.innerWidth)  * 2 - 1;
  mouse.y = -(mouseY / window.innerHeight) * 2 + 1;

  // Update the raycaster with the camera and mouse position
  const view = views.getActive();
  raycaster.setFromCamera(mouse, view.camera);

  // Find intersections with candidates
  const intersects = raycaster.intersectObjects(trackableBodies);
  if (intersects.length === 0)
    return null;

  return {
    object: intersects[0].object,
    point: intersects[0].point // point on the surface in world space
  };
}

// Lock the camera into a geostationary orbit around the selected object
function lockToOrbit(objectToLock, surfacePoint) {

  // Set a marker in local coordinates on object's surface point
  const marker = createMarker(toUnits(50), 0x00ff00);
  attachToSurface(marker, objectToLock, surfacePoint);

  // Lock the active view aligned to object's center
  views.lockToOrbitView(marker, objectToLock);
}

// Place an observer on an object surface
function enterObserverMode(object, surfacePoint) {

  // Currently we handle only one observer
  console.assert(observerState.object === null, "Setting already existing observer");

  // Position and orient the marker on the surface
  const marker = createMarker(toUnits(10), 0xFFFFFF);
  attachToSurface(marker, object, surfacePoint);

  observerState.object = object;
  observerState.marker = marker;

  // Init observer events
  observerState.observerOnEarth = (object === earth);
  observerState.moonVisible = isAboveHorizon(tiltedMoon, toUnits(MOON_RADIUS_KM));
  observerState.sunVisible = isAboveHorizon(sunLight, 0); // FIXME can have one fake event if sun at set/rise

  // Create a new observer view placed on marker
  const eyeHeight = toUnits(5); // km above surface
  const lookAhead = toUnits(100); // look at km ahead on horizon
  const viewIndex = views.createObserverView(marker, eyeHeight, lookAhead);
  observerState.viewIndex = viewIndex;

  // Lock the view camera on the marker
  const view = views.get(viewIndex);
  view.lockTo(marker, true);

  return viewIndex;
}

// Move the marker to a new position on planet surface
function placeObserverAt(latDeg, lonDeg) {

  const view = views.get(observerState.viewIndex);
  if (views.getActive() !== view)
    return;

  const latRad = toRadians(latDeg);
  const lonRad = toRadians(lonDeg);
  const radius = observerState.marker.position.length();

  // Convert spherical coordinates to Cartesian (x, y, z) in the planet's local
  // frame. Y is the polar axis. +X is the prime meridian (0° longitude).
  // The -z for sine is to match the longitude calculation in getGeoData.
  const newSurfacePoint = new THREE.Vector3();
  newSurfacePoint.y = radius * Math.sin(latRad);
  const xzRadius = radius * Math.cos(latRad); // Radius of the circle at this latitude
  newSurfacePoint.x = xzRadius * Math.cos(lonRad);
  newSurfacePoint.z = -xzRadius * Math.sin(lonRad);

  // Move the marker to new surface point and realign its plane
  // Surface point must be in world coords
  const object = observerState.object;
  object.localToWorld(newSurfacePoint)
  attachToSurface(observerState.marker, object, newSurfacePoint);

  // Camera is already locked to the marker, locking update will
  // set correct camera and target position at next frame.
}

// Drop observer view and release relative resources
function exitObserverMode() {
  const view = views.get(observerState.viewIndex);
  view.unlock();
  const marker = observerState.marker;
  marker.parent.remove(marker);
  disposeMarker(marker);
  views.dispose(observerState.viewIndex);
  observerState.object = null;
  observerState.viewIndex = null;
  observerState.marker = null;
}

// ============================================================================
// CELESTIAL MECHANICS
// ============================================================================

// Computes an array of 3D vertex on an elliptic curve in the Moon's orbital plane.
// The local coordinate convention for the orbital planes is:
//
// - Nearest focus is at the origin (0,0,0)
// - +X axis represents the "line of nodes," pointing to the Ascending Node.
// - XZ plane represents the orbital plane.
// - +Y axis is the UP direction, orbit at the ascending node moves from -Y to +Y
// - +Z follows a right-handed local frame, at the ascending node the direction of
//   a prograde (counter-clockwise) orbit will be OPPOSITE of +Z axis
function ellipticCurve(A, EC, W) {
  const SEGMENTS = 360;
  const points = new Float32Array(SEGMENTS * 3);

  // Distance from focus given true anomaly (ellipse polar equation)
  const radius = ta => A * (1 - EC * EC) / (1 + EC * Math.cos(ta));

  // Loop starts at perigee (W) and moves in counter-clockwise direction
  for (let i = 0; i < SEGMENTS; i++) {
    const ta = (i / SEGMENTS) * 2 * Math.PI; // true anomaly
    const u = W + ta; // argument of latitude (angle from ascending node)
    const r = radius(ta); // distance from focus at true anomaly
    points[i*3 + 0] = r * Math.cos(u); // x
    points[i*3 + 1] = 0;               // y  (on orbital plane)
    points[i*3 + 2] =-r * Math.sin(u); // -z due to local frame conventions
  }

  // Ascending and descending nodes x-axis coordinates
  const rAsc = radius(-W);
  const rDes = radius(-W + Math.PI);
  return [points, rAsc, rDes];
}

// Solves Kepler's Equation for Eccentric Anomaly (E) with
// the Newton-Raphson iterative method
function solveKepler(M, e) {

  // Kepler's Equation is: M = E - e * sin(E)
  const maxIterations = 10;
  const tolerance = 1e-6; // A small tolerance for accuracy
  let E = M; // Initial guess for E is M

  for (let i = 0; i < maxIterations; i++) {
    const f = E - e * Math.sin(E) - M; // The function we want to find the root of
    const fPrime = 1 - e * Math.cos(E); // The derivative df/dE
    const deltaE = f / fPrime;

    E = E - deltaE; // New, better guess for E

    if (Math.abs(deltaE) < tolerance)
      break; // Solution is accurate enough
  }
  return E;
}

// Solve an elliptical orbit with given osculating elements (oe) at epoch time and
// elapsed time since epoch according to local frame conventions of orbital planes.
function solveOrbit(elapsedTime, oe) {

  // Solve Kepler's equation to get E (Eccentric Anomaly, the angle from
  // ellipse center if orbit was a circle) given EC (Eccentricity) and
  // M (Current Mean Anomaly, the angle from periapsis if orbit was a circle)
  const n = 2 * Math.PI / oe.PR; // Mean motion (rad/sec)
  const M = oe.MA + n * elapsedTime; // Mean Anomaly
  const EC = oe.EC; // Eccentricity
  const E = solveKepler(M, EC); // Eccentric anomaly

  // Calculate the True Anomaly (TA or ν), and the angle from
  // perige (viewed from the nearest focus)
  const [sinE, cosE] = [Math.sin(E), Math.cos(E)];
  const cosTA = (cosE - EC) / (1 - EC * cosE);
  const sinTA = Math.sqrt(1 - EC * EC) * sinE / (1 - EC * cosE);
  const TA = Math.atan2(sinTA, cosTA);

  // Argument of Latitude (u) = Argument of Periapsis (ω) + True Anomaly (ν)
  const u = oe.W + TA;

  // Radius as distance from focus
  const r = oe.A * (1 - EC * EC) / (1 + EC * Math.cos(TA));

  // Position in the XZ orbital plane.
  // At Ascending Node u = 0 -> [r, 0]
  const x =  r * Math.cos(u);
  const z = -r * Math.sin(u); // -z for prograde motion
  return [x, z];
}

// Calculate the Moon position in the Moon orbital plane
function getMoonEBMPosition(elapsedTime) {

  // Position of Moon in the local frame of the 2D orbital XZ plane
  const [x_moon, z_moon] = solveOrbit(elapsedTime, MOON_DATA);

  // Convert to 3D with +Y axis perpendicular to orbital plane
  return [x_moon, 0, z_moon];
}

// Calculate the Earth-Moon barycenter (EBM) position in the Sun orbital plane
function getEBMSunPosition(elapsedTime) {

  // Position of EBM in the heliocentric frame of solar orbital plane
  const [x_ebm, z_ebm] = solveOrbit(elapsedTime, EMB_DATA);

  // Convert to 3D with +Y axis perpendicular to orbital plane
  return [x_ebm, 0, z_ebm];
}

function isAboveHorizon(target, radius) {

  // Get target's position in the observer frame
  const temp = observerState.tempVec;
  target.getWorldPosition(temp);
  const targetLocalPos = observerState.marker.worldToLocal(temp);

  // Correction for the object's upper limb (its radius)
  const radiusCorrection = radius;

  // Correction for atmospheric refraction (lifts the image)
  let refractionCorrection = 0;
  if (observerState.observerOnEarth) {
    const distance = targetLocalPos.length();
    refractionCorrection = distance * Math.tan(HORIZON_REFRACTION);
  }

  // The object is visible if its center is above this negative threshold
  const visibilityThreshold = -(radiusCorrection + refractionCorrection);
  return targetLocalPos.y > visibilityThreshold;
}

// Event types
export const CELESTIAL_EVENTS = {
    RISE: 'rise',
    SET: 'set',
};

class CelestialEventManager {
  constructor() {
    this.listeners = new Map();
  }
  on(eventType, callback) {
    if (!this.listeners.has(eventType)) {
        this.listeners.set(eventType, []);
    }
    this.listeners.get(eventType).push(callback);
  }
  emit(eventType, data) {
    const listeners = this.listeners.get(eventType) || [];
    listeners.forEach(callback => callback(data));
  }
  checkVisibility(object, name, radius, timeForward, prevState) {
    const isVisible = isAboveHorizon(object, radius);
    if (isVisible !== prevState) {
        const atRise = (isVisible === timeForward);
        if (atRise) {
            this.emit(CELESTIAL_EVENTS.RISE, name);
        } else {
            this.emit(CELESTIAL_EVENTS.SET, name);
        }
        prevState = isVisible;
    }
    return isVisible;
  }
};

// ============================================================================
// ANIMATION LOOP
// ============================================================================

// Clock works also when tab is hidden, can be set/reset by UI, time
// can run faster and/or backward from real time and is adjustable
const SimClock = class {
  constructor(masterEpoch) {
    this.masterEpochTime = masterEpoch.getTime(); // our t=0
    this.reset();
    this.running = true;
  }
  reset() {
    this.simulationTimeAtPause = Date.now();
    this.realTimeAtResume = this.simulationTimeAtPause;
    this.speedX = SIM_TIME_SPEED_UP;
  }
  setDate(newDate) {
    // Adjust the "banked" time to make the total time equal the newDate
    this.simulationTimeAtPause = newDate.getTime() - this._deltaSinceLastResume();
  }
  _deltaSinceLastResume() {
    // Accumulate time only while running. It is simulation time, not real time
    return this.running ? this.speedX * (Date.now() - this.realTimeAtResume) : 0;
  }
  getTime() {
    const simTime = this.simulationTimeAtPause + this._deltaSinceLastResume();
    return simTime; // in msecs
  }
  elapsed() {
    // Initial offsets in simulation are computed on master epoch
    return this.getTime() - this.masterEpochTime;
  }
  togglePause() {
    if (this.running) {
      // Before stopping, add the "ticking" time to the "banked" time
      this.simulationTimeAtPause += this._deltaSinceLastResume();
    } else {
      this.realTimeAtResume = Date.now();
    }
    this.running = !this.running;
    return this.running;
  }
  speed() {
    return this.speedX / SIM_TIME_SPEED_UP; // SIM_TIME_SPEED_UP -> speed == 1
  }
  setSpeed(speed) {
    // Bank any accumulated time at the old speed by simulating a
    // stop/start, then set the new speed. It works whether the
    // clock is running or paused.
    this.togglePause();
    this.togglePause();
    this.speedX = SIM_TIME_SPEED_UP * speed;
  }
};

const simStepData = { azEl: [], latLon: [] };

// Rescaled Sun distance for placing directional Sun light source
const SUN_LIGHT_DISTANCE = toUnits(10 * MOON_DISTANCE_KM);

const earthPosWorldVec = new THREE.Vector3();
const moonPosWorldVec = new THREE.Vector3();
const embPosWorldVec = new THREE.Vector3();

// Animation loop function
function animate(simulation) {

  // Three.js rotation order is 'XYZ' but astronomical standard defines
  // the orientation of an orbital plane in a specific sequence:
  // 1. Rotate around the Pole (OM)
  // 2. Tilt around the Line of Nodes (IN)

  const elpasedMsec = simulation.clock.elapsed(); // in msecs
  const elapsed = elpasedMsec / 1000; // in secs

  // Initial static rotations of the Sun orbital plane
  // Set the Euler rotation order to 'YXZ' to matche the
  // astronomical convention for an orbital plane.
  sunOrbitalPlane.rotation.order = 'YXZ';
  sunOrbitalPlane.rotation.x = InitialEarthOrbitX;
  sunOrbitalPlane.rotation.y = InitialEarthOrbitY;

  // EMB orbit in the Sun orbital plane, its XZ plane is the Ecliptic
  const [xe, ye, ze] = getEBMSunPosition(elapsed);
  embPosWorldVec.set(xe, ye, ze);

  // Use a rescaled EMB-Sun distance for rendering purposes
  if (!simulation.validateMode) {
    embPosWorldVec.normalize().multiplyScalar(SUN_LIGHT_DISTANCE);
  }
  embPivot.position.copy(embPosWorldVec);

  // Inclination to Ecliptic and ascending node precession
  // in backwards (retrograde) direction to Moon orbital plane
  moonOrbitalPlane.rotation.order = 'YXZ';
  moonOrbitalPlane.rotation.x = InitialMoonOrbitX;
  moonOrbitalPlane.rotation.y = InitialAscendingNodePivotY - moonNodeSpeed * elapsed;

  // Moon orbit in the Moon orbital plane (EMB is the focus)
  const [xm, ym, zm] = getMoonEBMPosition(elapsed);
  tiltedMoon.position.set(xm, ym, zm);

  // Moon's axis tilt
  tiltedMoon.rotation.x = InitialTiltedMoonX;

  // Moon rotation around its Pole axis, in tidal locking with Earth
  moon.rotation.y = InitialMoonY + moonSiderealRotationSpeed * elapsed;

  // Earth axial precession in clockwise (negative) direction
  tiltedEarth.rotation.x = InitialTiltedEarthX;
  tiltedEarth.rotation.y = InitialPrecessionY - earthPrecessionSpeed * elapsed;

  // Rotate Earth
  earth.rotation.y = InitialEarthY + earthRotationSpeed * elapsed;

  // Earth placement according to barycenter rule
  //
  // Earth lies on the Moon's orbital plane, where EMB is at
  // the Origin (0,0,0), so we rescale and invert the EBM->Moon
  // vector in Moon's orbital plane
  tiltedEarth.position.copy(tiltedMoon.position) // EBM->Moon
                      .multiplyScalar(MOON_EARTH_MASS_RATIO)
                      .negate(); // EBM->Moon -> Moon->EMB

  if (simulation.validateMode) {
    // Force hierarchy recalculation and recompute real positions
    scene.updateWorldMatrix(false, true);
    const m = tiltedMoon.getWorldPosition(moonPosWorldVec);
    const e = tiltedEarth.getWorldPosition(earthPosWorldVec);

    const moonV  = [fromUnits(m.x), fromUnits(m.y), fromUnits(m.z)];
    const earthV = [fromUnits(e.x), fromUnits(e.y), fromUnits(e.z)];
    const timeV = elpasedMsec + simulation.clock.masterEpochTime;
    return {
      time: timeV,        // msec
      sunPosition: earthV,  // km
      moonPosition: moonV // km
    };
  }

  // Use a rescaled EMB-Sun distance for rendering purposes
  //embPivot.position.normalize().multiplyScalar(SUN_LIGHT_DISTANCE);
  scene.updateWorldMatrix(true, true);

  // Set Sun light to look at Earth
  tiltedEarth.getWorldPosition(earthPosWorldVec);
  sunLight.target.position.copy(earthPosWorldVec);

  // Update the end point of the line to match the sun's new position
  if (DEBUG)
    set_sunline_length(earthPosWorldVec);

  if (observerState.object) {
    // Calculate the equivalent radius using the captured real distance
    const sunRealDistance = earthPosWorldVec.length();
    const equivalentSunRadius = toUnits(SUN_RADIUS_KM) * (SUN_LIGHT_DISTANCE / sunRealDistance);

    // Check and emit celestial events
    const timeForward = (simulation.clock.speed() > 0);
    observerState.moonVisible = simulation.eventManager.checkVisibility(
        tiltedMoon, "Moon", toUnits(MOON_RADIUS_KM), timeForward, observerState.moonVisible
    );
    observerState.sunVisible = simulation.eventManager.checkVisibility(
        sunLight, "Sun", equivalentSunRadius, timeForward, observerState.sunVisible
    );

    // If we are in observer view pass elevation and azimuth
    const view = views.get(observerState.viewIndex);
    const isAct = (view == views.getActive());
    const { azEl, latLon } = isAct ? view.getGeoData(observerState.marker) : { azEl: [], latLon: []};
    Object.assign(simStepData, { azEl: azEl, latLon: latLon });
  }

  // If is first frame init main view now that we know Earth position
  if (views.getActive() === null)
    views.init(earthPosWorldVec);

  // Update the active controls and render with the active camera
  const activeCamera = views.update();
  renderer.render(scene, activeCamera);

  return simStepData;
}

// ============================================================================
// EXPORT CLASS
// ============================================================================

class Simulation {
  constructor(validateMode) {
    // Don't render and return Moon / Earth positions
    this.validateMode = validateMode;

    // Our simulation clock
    this.clock = new SimClock(MASTER_EPOCH);

    // Create a new event manager and expose its 'on' method
    this.eventManager = new CelestialEventManager();
    this.on = this.eventManager.on.bind(this.eventManager);

    this.update = () => animate(this);
    this.getTime = this.clock.getTime.bind(this.clock);
    this.setDate = this.clock.setDate.bind(this.clock);
    this.speed = this.clock.speed.bind(this.clock);
    this.setSpeed = this.clock.setSpeed.bind(this.clock);
    this.togglePause = this.clock.togglePause.bind(this.clock);
    this.setActiveView = views.setActive.bind(views);
    this.disposeView = views.dispose.bind(views);
    this.lockToOrbit = lockToOrbit;
    this.enterObserverMode = enterObserverMode;
    this.placeObserverAt = placeObserverAt;
    this.exitObserverMode = exitObserverMode;
    this.pickObject = pickObject;
  }
  getRenderer() {
    return renderer;
  }
  reverseSpeed() {
    const speed = -this.clock.speed();
    this.clock.setSpeed(speed);
    return speed;
  }
  reset() {
    this.clock.reset();
    views.setDefault();
  }
  isObserverView() {
    return views.getActive() === views.get(observerState.viewIndex);
  }
  isOrbitLocked(object) {
    const lockedObjects = views.getOrbitLockedObjects();
    return lockedObjects.includes(object);
  }
  unlockCamera() {
    const view = views.getActive();
    const marker = view.cameraLock.target;
    marker.parent.remove(marker);
    disposeMarker(marker);
    view.unlock();
  }
  cloneView() {
    const v = views.getActive();
    const newViewIndex = views.clone(v);
    return newViewIndex;
  }
  resize() {
    const v = views.getActive();
    const camera = v.camera;
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    views.renderer.setSize(innerWidth, innerHeight);
  }
};

export default Simulation;
